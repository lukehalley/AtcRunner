import { type Token, BaseToken, WrapperToken } from "./token";
import { type ChainIdTypeMap } from "./common/chainid";
import { ID } from "./internal/types";
import { BigNumber } from "@ethersproject/bignumber";
import type { Signer } from "@ethersproject/abstract-signer";
import type { ContractTransaction } from "@ethersproject/contracts";
export declare namespace Tokens {
    /**
     * The DAI stablecoin, available on Arbitrum, Avalanche, Binance Smart Chain, Ethereum, and Polygon.
     */
    const DAI: BaseToken;
    const BUSD: BaseToken;
    const USDC: BaseToken;
    const USDT: BaseToken;
    const UST: BaseToken;
    /**
     * ETH is the native currency ("gas token") for Ethereum, Optimism,
     * Boba, Arbitrum, and countless other chains
     * (though the four listed are the four currently supported by Synapse Protocol).
     * See {@link WETH} for a "wrapped" ERC20 variant of ETH.
     */
    const ETH: BaseToken;
    /**
     * nETH is a token involved in the bridge.
     */
    const NETH: BaseToken;
    const WETH: BaseToken;
    const WETHBEAM: BaseToken;
    const WETH_E: BaseToken;
    const AVWETH: BaseToken;
    const ONE_ETH: BaseToken;
    const FTM_ETH: BaseToken;
    const METIS_ETH: BaseToken;
    const SYN: BaseToken;
    /**
     * nUSD is a token involved in the bridge.
     */
    const NUSD: BaseToken;
    const DFK_USDC: BaseToken;
    /**
     * AVAX is the native currency of Avalanche C-Chain.
     * See {@link WAVAX} for the "wrapped" ERC20 variant of this token.
     */
    const AVAX: BaseToken;
    const WAVAX: WrapperToken;
    /**
     * SYN_AVAX (synAVAX) is a "wrapped" ERC20 form of AVAX,
     * and is the supported output Token when bridging AVAX from
     * Avalanche C-Chain or Defi Kingdoms mainnet to Harmony.
     */
    const SYN_AVAX: BaseToken;
    const MULTI_AVAX: BaseToken;
    /**
     * MOVR is the native currency of the Moonriver chain.
     * See {@link WMOVR} for the "wrapped" ERC20 variant of this token.
     */
    const MOVR: BaseToken;
    const WMOVR: WrapperToken;
    /**
     * GAS_JEWEL is the native currency of the DeFi Kingdoms chain.
     * See {@link JEWEL} for the "wrapped" ERC20 variant of this token.
     */
    const GAS_JEWEL: BaseToken;
    /**
     * JEWEL is a "wrapped" ERC20 variant of {@link GAS_JEWEL}.
     * In the context of Synapse Protocol, JEWEL is primarily used for
     * bridging the native currency of the DeFi Kingdoms mainnet, {@link GAS_JEWEL},
     * to and from the Harmony and Avalanche networks.
     */
    const JEWEL: WrapperToken;
    /**
     * SYN_JEWEL ("synJewel") is an ERC20 Token used by Synapse Protocol to
     * bridge and "wrap" the native currency of the DeFi Kingdoms mainnet, {@link GAS_JEWEL},
     * to and from Avalanche C-Chain.
     *
     * synJEWEL is supported on Harmony as an "intermediate" token; for example, it is
     * possible to bridge {@link JEWEL} from Harmony to synJEWEL on Avalanche, and then
     * bridge synJEWEL to native {@link GAS_JEWEL} on the DeFi Kingdoms mainnet.
     */
    const SYN_JEWEL: BaseToken;
    const MULTIJEWEL: BaseToken;
    const XJEWEL: BaseToken;
    const GOHM: BaseToken;
    const HIGH: BaseToken;
    const JUMP: BaseToken;
    const DOG: BaseToken;
    const NFD: BaseToken;
    const FRAX: BaseToken;
    const SYN_FRAX: BaseToken;
    const SOLAR: BaseToken;
    const GMX: BaseToken;
    const NEWO: BaseToken;
    const SDT: BaseToken;
    const LUNA: BaseToken;
    const USDB: BaseToken;
    const VSTA: BaseToken;
    const mintBurnTokens: Token[];
    const isMintBurnToken: (token: Token) => boolean;
    const ChainGasTokensMap: ChainIdTypeMap<Token>;
    /**
     * Returns the native currency Token ("gas token") for a given chain, if
     * it's supported by Synapse Protocol.
     * @param chainId
     */
    const gasTokenForChain: (chainId: number) => Token | null;
    /**
     * Returns the "wrapper" Token for a given native currency Token ("gas token")
     * if such Token exists and is supported by Synapse Protocol.
     * @param gasToken
     */
    const gasTokenWrapper: (gasToken: Token) => Token | null;
    /**
     * @param {number} chainId Chain ID of the network on which to fetch the spend allowance of `spender` for `owner`'s `token`
     * @param {Token} token Token to fetch allowance information of
     * @param {string} owner Address for owner of `token`
     * @param {string} spender Address for spender of `owner`'s `token`
     */
    interface CheckTokenAllowanceParams {
        chainId: number;
        token: Token;
        owner: string;
        spender: string;
    }
    /**
     * checkTokenAllowance returns the amount of `args.token` belonging to `args.owner`
     * which `args.spender` is allowed to spend on behalf of `args.owner`.
     * @param {CheckTokenAllowanceParams} args {@link CheckTokenAllowanceParams} object containing arguments
     * @param {number} args.chainId Chain ID of the network on which to fetch the spend allowance of `spender` for `owner`'s `token`.
     * @param {Token} args.token Token to fetch allowance information of.
     * @param {string} args.owner Address for owner of `token`
     * @param {string} args.spender Address for spender of `owner`'s `token`
     */
    function checkTokenAllowance(args: CheckTokenAllowanceParams): Promise<BigNumber>;
    /**
     * @param {number} chainId Chain ID of the network on which to approve the spend allowance of `spender` for `signer`'s `token`
     * @param {Token} token Token to approve
     * @param {string} spender Address of spender to approve use of `signer`'s `token`
     * @param {BigNumber} amount [Optional] amount of `owner`'s `token` to approve for spend by `spender`. Defaults to uint256 max (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) if not provided.
     */
    interface ApproveTokenParams extends Omit<CheckTokenAllowanceParams, "owner"> {
        amount?: BigNumber;
        signer: Signer;
    }
    /**
     * approveTokenSpend approves `args.spender` to spend `args.amount` (or the ERC20 max approval amount)
     * of `args.token` belonging to `args.signer`
     * @param {ApproveTokenParams} args {@link ApproveTokenParams} object containing arguments
     * @param {number} args.chainId Chain ID of the network on which to approve the spend allowance of `spender` for `signer`'s `token`
     * @param {Token} args.token Token to approve
     * @param {string} args.spender Address of spender to approve use of `signer`'s `token`
     * @param {BigNumber} args.amount [Optional] amount of `owner`'s `token` to approve for spend by `spender`. Defaults to uint256 max (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) if not provided.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    function approveTokenSpend(args: ApproveTokenParams): Promise<ContractTransaction>;
    const AllTokens: Token[];
    /**
     * Returns a {@link Token} object based on the passed `tokenSymbol`, if such token exists.
     *
     * @param tokenSymbol Actual token symbol ("DAI", "SYN") or the `id` field of a {@link Token} object.
     *
     * @return A {@link Token} if one matches the passed `tokenSymbol`, null otherwise.
     */
    function tokenFromSymbol(tokenSymbol: string | ID | symbol): Token | null;
}
