import { ChainId } from "./chainid.js";
import { Tokens } from "../tokens.js";
import { SwapPools } from "../swappools.js";
import { BridgeUtils } from "../bridge/bridgeutils.js";
import _ from "lodash";
export var Networks;
(function (Networks) {
    var _a;
    var tokenSupportChecks = [
        { chainId: ChainId.ETH, token: Tokens.WETH },
        { chainId: ChainId.ETH, token: Tokens.NETH },
        { chainId: ChainId.AVALANCHE, token: Tokens.AVAX },
        { chainId: ChainId.AVALANCHE, token: Tokens.WAVAX },
        { chainId: ChainId.AVALANCHE, token: Tokens.AVWETH },
        { chainId: ChainId.MOONRIVER, token: Tokens.MOVR },
        { chainId: ChainId.MOONRIVER, token: Tokens.WMOVR },
        { chainId: ChainId.DFK, token: Tokens.GAS_JEWEL },
        { chainId: ChainId.DFK, token: Tokens.JEWEL },
    ];
    var checkWrappedToken = function (chainId, token) {
        var check = tokenSupportChecks.find(function (check) {
            return check.chainId === chainId && check.token.isEqual(token);
        });
        return typeof check !== "undefined";
    };
    var Network = /** @class */ (function () {
        function Network(args) {
            var _this = this;
            this.name = args.name;
            this.chainId = args.chainId;
            this.chainCurrency = args.chainCurrency;
            this.tokens = SwapPools.getAllSwappableTokensForNetwork(this.chainId);
            this.tokenAddresses = this.tokens.map(function (t) { return t.address(_this.chainId); });
            this.id = Symbol("".concat(this.name, ":").concat(this.chainId));
        }
        Object.defineProperty(Network.prototype, "zapIsL2BridgeZap", {
            /**
             * Returns true if the Bridge Zap contract for this network
             * is a L2BridgeZap contract.
             * Currently, Ethereum mainnet is the only network for which the
             * Bridge Zap contract is a NerveBridgeZap contract.
             */
            get: function () {
                return this.chainId !== ChainId.ETH && this.chainId !== ChainId.DFK;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns true if the passed token is available on this network.
         * @param {Token} token A {@link Token} object.
         */
        Network.prototype.supportsToken = function (token) {
            var checkSymbol = token.symbol;
            var isEthish = checkSymbol === "ETH" && (this.chainId === ChainId.ETH || BridgeUtils.isL2ETHChain(this.chainId)), isWrapped = checkWrappedToken(this.chainId, token);
            if (isEthish || isWrapped) {
                return true;
            }
            var tokenAddr = token.address(this.chainId);
            return tokenAddr !== null
                ? this.tokenAddresses.includes(tokenAddr)
                : false;
        };
        Object.defineProperty(Network.prototype, "bridgeableTokens", {
            get: function () {
                var tokens = [];
                var chainGasToken = Tokens.gasTokenForChain(this.chainId);
                this.tokens.forEach(function (t) {
                    if (!_.isNull(chainGasToken)) {
                        var gasWrapper = Tokens.gasTokenWrapper(chainGasToken);
                        if (gasWrapper.isEqual(t)) {
                            return;
                        }
                    }
                    tokens.push(t);
                });
                return tokens;
            },
            enumerable: false,
            configurable: true
        });
        return Network;
    }());
    Networks.Network = Network;
    Networks.ETH = new Network({
        name: "Ethereum Mainnet",
        chainId: ChainId.ETH,
        chainCurrency: "ETH"
    });
    Networks.OPTIMISM = new Network({
        name: "Optimism",
        chainId: ChainId.OPTIMISM,
        chainCurrency: "ETH"
    });
    Networks.CRONOS = new Network({
        name: "Cronos",
        chainId: ChainId.CRONOS,
        chainCurrency: "CRO"
    });
    Networks.BSC = new Network({
        name: "Binance Smart Chain",
        chainId: ChainId.BSC,
        chainCurrency: "BNB",
    });
    Networks.POLYGON = new Network({
        name: "Polygon",
        chainId: ChainId.POLYGON,
        chainCurrency: "MATIC",
    });
    Networks.FANTOM = new Network({
        name: "Fantom",
        chainId: ChainId.FANTOM,
        chainCurrency: "FTM",
    });
    Networks.BOBA = new Network({
        name: "Boba Network",
        chainId: ChainId.BOBA,
        chainCurrency: "ETH",
    });
    Networks.METIS = new Network({
        name: "Metis",
        chainId: ChainId.METIS,
        chainCurrency: "Metis",
    });
    Networks.MOONBEAM = new Network({
        name: "Moonbeam",
        chainId: ChainId.MOONBEAM,
        chainCurrency: "GLMR",
    });
    Networks.MOONRIVER = new Network({
        name: "Moonriver",
        chainId: ChainId.MOONRIVER,
        chainCurrency: "MOVR",
    });
    Networks.ARBITRUM = new Network({
        name: "Arbitrum",
        chainId: ChainId.ARBITRUM,
        chainCurrency: "ETH",
    });
    Networks.AVALANCHE = new Network({
        name: "Avalanche C-Chain",
        chainId: ChainId.AVALANCHE,
        chainCurrency: "AVAX",
    });
    Networks.DFK = new Network({
        name: "DeFi Kingdoms",
        chainId: ChainId.DFK,
        chainCurrency: "JEWEL"
    });
    Networks.AURORA = new Network({
        name: "Aurora",
        chainId: ChainId.AURORA,
        chainCurrency: "aETH",
    });
    Networks.HARMONY = new Network({
        name: "Harmony",
        chainId: ChainId.HARMONY,
        chainCurrency: "ONE",
    });
    var CHAINID_NETWORK_MAP = (_a = {},
        _a[ChainId.ETH] = Networks.ETH,
        _a[ChainId.OPTIMISM] = Networks.OPTIMISM,
        _a[ChainId.CRONOS] = Networks.CRONOS,
        _a[ChainId.BSC] = Networks.BSC,
        _a[ChainId.POLYGON] = Networks.POLYGON,
        _a[ChainId.FANTOM] = Networks.FANTOM,
        _a[ChainId.BOBA] = Networks.BOBA,
        _a[ChainId.METIS] = Networks.METIS,
        _a[ChainId.MOONBEAM] = Networks.MOONBEAM,
        _a[ChainId.MOONRIVER] = Networks.MOONRIVER,
        _a[ChainId.ARBITRUM] = Networks.ARBITRUM,
        _a[ChainId.AVALANCHE] = Networks.AVALANCHE,
        _a[ChainId.DFK] = Networks.DFK,
        _a[ChainId.AURORA] = Networks.AURORA,
        _a[ChainId.HARMONY] = Networks.HARMONY,
        _a);
    Networks.networkName = function (chainId) { return Networks.fromChainId(chainId).name; };
    Networks.fromChainId = function (chainId) { var _a; return (_a = CHAINID_NETWORK_MAP[chainId]) !== null && _a !== void 0 ? _a : null; };
    /**
     * Returns true if the passed network supports the passed token.
     * @param {Network | number} network Either a {@link Network} instance, or the Chain ID of a supported network.
     * @param {Token} token A {@link Token} object.
     */
    Networks.networkSupportsToken = function (network, token) {
        return (network instanceof Network
            ? network
            : Networks.fromChainId(network)).supportsToken(token);
    };
    Networks.supportedNetworks = function () { return Object.values(CHAINID_NETWORK_MAP); };
})(Networks || (Networks = {}));
export var supportedNetworks = Networks.supportedNetworks;
