var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { isEqual } from "lodash-es";
import { Tokens } from "./tokens.js";
import { ChainId, supportedChainIds } from "./common/chainid.js";
import { BaseToken } from "./token.js";
import { SwapType } from "./internal/swaptype.js";
import { BigNumber } from "@ethersproject/bignumber";
export var SwapPools;
(function (SwapPools) {
    var _a, _b, _c, _d, _e;
    function moveFirstToLast(arr) {
        return __spreadArray(__spreadArray([], arr.slice(1), true), [
            arr[0]
        ], false);
    }
    var makeSwapToken = function (args) {
        var _a;
        var _b, _c;
        return new SwapToken({
            name: "Synapse nUSD LP Token".concat(args.netName != "BSC" ? " ".concat(args.netName) : ""),
            poolName: "".concat(args.netName, " Stableswap Pool "),
            symbol: (_b = args.symbol) !== null && _b !== void 0 ? _b : (((_c = args.notLP) !== null && _c !== void 0 ? _c : false) ? "nUSD" : "nUSD-LP"),
            chainId: args.chainId,
            decimals: 18,
            poolId: args.poolId,
            poolTokens: args.poolTokens,
            addresses: (_a = {}, _a[args.chainId] = args.address, _a),
            swapAddress: args.swapAddress,
            poolType: SwapType.USD,
        });
    };
    var makeETHSwapToken = function (args) {
        var _a;
        var _b, _c, _d;
        return new ETHSwapToken({
            name: "Synapse ".concat((_b = args.poolName) !== null && _b !== void 0 ? _b : "ETH", " LP Token ").concat(args.netName),
            poolName: "".concat(args.netName, " ").concat((_c = args.poolName) !== null && _c !== void 0 ? _c : "ETH", " Pool "),
            symbol: (_d = args.symbol) !== null && _d !== void 0 ? _d : "nETH-LP",
            chainId: args.chainId,
            decimals: 18,
            poolId: args.poolId,
            addresses: (_a = {}, _a[args.chainId] = args.address, _a),
            swapAddress: args.swapAddress,
            swapEthAddress: args.swapETHAddress,
            poolTokens: args.poolTokens,
            nativeTokens: args.nativeTokens,
            depositTokens: args.depositTokens,
            poolType: SwapType.ETH,
        });
    };
    var SwapToken = /** @class */ (function () {
        function SwapToken(args) {
            this.baseToken = new BaseToken({
                name: args.name,
                symbol: args.symbol,
                decimals: args.decimals,
                addresses: args.addresses,
                swapType: args.poolType
            });
            this.chainId = args.chainId;
            this.poolId = args.poolId;
            this.poolName = args.poolName;
            this.poolType = args.poolType;
            this.swapAddress = args.swapAddress;
            this.poolTokens = args.poolTokens;
        }
        Object.defineProperty(SwapToken.prototype, "id", {
            get: function () {
                return this.baseToken.id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SwapToken.prototype, "name", {
            get: function () {
                return this.baseToken.name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SwapToken.prototype, "symbol", {
            get: function () {
                return this.baseToken.symbol;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SwapToken.prototype, "addresses", {
            get: function () {
                return this.baseToken.addresses;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SwapToken.prototype, "swapType", {
            get: function () {
                return this.baseToken.swapType;
            },
            enumerable: false,
            configurable: true
        });
        SwapToken.prototype.address = function (chainId) {
            return this.baseToken.address(chainId);
        };
        SwapToken.prototype.decimals = function (chainId) {
            return this.baseToken.decimals(chainId);
        };
        Object.defineProperty(SwapToken.prototype, "poolTokensForBridgeSwaps", {
            get: function () {
                return moveFirstToLast(this.poolTokens);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SwapToken.prototype, "swapETHAddress", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        SwapToken.prototype.liquidityAmountsMap = function () {
            var m = {};
            for (var _i = 0, _a = this.poolTokens; _i < _a.length; _i++) {
                var t = _a[_i];
                m[t.symbol] = BigNumber.from(0);
            }
            return m;
        };
        SwapToken.prototype.liquidityAmountsFromMap = function (m) {
            var _this = this;
            var amounts = new Array(this.poolTokens.length);
            var mapKeys = Object.keys(m);
            var wantMapKeys = Object.keys(this.liquidityAmountsMap());
            if (!isEqual(mapKeys, wantMapKeys)) {
                var err = new Error("expected passed PoolTokensAmountsMap to have keys ".concat(wantMapKeys, "; got ").concat(mapKeys));
                console.error(err);
                return amounts;
            }
            mapKeys.forEach(function (k, idx) {
                var amt = m[k];
                var realAmt;
                if (amt instanceof BigNumber) {
                    realAmt = amt;
                }
                else {
                    var token = _this.poolTokens[idx];
                    realAmt = token.etherToWei(amt, _this.chainId);
                }
                amounts[idx] = realAmt;
            });
            return amounts;
        };
        return SwapToken;
    }());
    SwapPools.SwapToken = SwapToken;
    var ETHSwapToken = /** @class */ (function (_super) {
        __extends(ETHSwapToken, _super);
        function ETHSwapToken(args) {
            var _this = this;
            var swapEthAddress = args.swapEthAddress, nativeTokens = args.nativeTokens, depositTokens = args.depositTokens, constructorArgs = __rest(args, ["swapEthAddress", "nativeTokens", "depositTokens"]);
            _this = _super.call(this, constructorArgs) || this;
            _this._swapETHAddress = null;
            if (swapEthAddress) {
                _this._swapETHAddress = args.swapEthAddress;
            }
            if (args.nativeTokens) {
                _this.nativeTokens = args.nativeTokens;
            }
            if (args.depositTokens) {
                _this.depositTokens = args.depositTokens;
            }
            return _this;
        }
        Object.defineProperty(ETHSwapToken.prototype, "poolTokensForBridgeSwaps", {
            get: function () {
                var _a;
                return ((_a = this.depositTokens) === null || _a === void 0 ? void 0 : _a.length) > 0
                    ? moveFirstToLast(this.depositTokens)
                    : moveFirstToLast(this.poolTokens);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ETHSwapToken.prototype, "swapETHAddress", {
            get: function () {
                return this._swapETHAddress;
            },
            enumerable: false,
            configurable: true
        });
        return ETHSwapToken;
    }(SwapToken));
    SwapPools.ETHSwapToken = ETHSwapToken;
    var USDPoolTokens = function (tok, nUSD) {
        if (tok === void 0) { tok = Tokens.DAI; }
        if (nUSD === void 0) { nUSD = true; }
        return __spreadArray(__spreadArray(__spreadArray([], (nUSD ? [Tokens.NUSD] : []), true), (tok === null ? [] : [tok]), true), [
            Tokens.USDC,
            Tokens.USDT,
        ], false);
    };
    var ETHTokensPool = function (t) { return [Tokens.NETH, t]; }, WETHTokenPool = ETHTokensPool(Tokens.WETH), ETHTokenPool = ETHTokensPool(Tokens.ETH);
    SwapPools.ETH_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.ETH,
        address: Tokens.NUSD.address(ChainId.ETH),
        netName: "Ethereum",
        poolId: 420,
        swapAddress: "0x1116898DdA4015eD8dDefb84b6e8Bc24528Af2d8",
        poolTokens: USDPoolTokens(Tokens.DAI, false),
        notLP: true
    });
    SwapPools.OPTIMISM_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.OPTIMISM,
        address: "0x2c6d91accC5Aa38c84653F28A80AEC69325BDd12",
        netName: "Optimism",
        poolId: 1,
        swapAddress: "0xF44938b0125A6662f9536281aD2CD6c499F22004",
        poolTokens: [Tokens.NUSD, Tokens.USDC],
    });
    SwapPools.OPTIMISM_ETH_SWAP_TOKEN = makeETHSwapToken({
        chainId: ChainId.OPTIMISM,
        address: "0x4619a06ddd3b8f0f951354ec5e75c09cd1cd1aef",
        netName: "Optimism",
        poolId: 0,
        swapAddress: "0xE27BFf97CE92C3e1Ff7AA9f86781FDd6D48F5eE9",
        swapETHAddress: "0x8c7d5f8A8e154e1B59C92D8FB71314A43F32ef7B",
        poolTokens: WETHTokenPool,
        nativeTokens: ETHTokenPool,
    });
    SwapPools.CRONOS_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.CRONOS,
        address: "0x8415D4EB17F0949e2388fdF52909db4cC0a2B082",
        netName: "Cronos",
        poolId: 0,
        swapAddress: "0x3b1601c386247A127287b094F9CCB585D4D0B99b",
        poolTokens: USDPoolTokens(),
    });
    SwapPools.BSC_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.BSC,
        address: "0xa4b7Bc06EC817785170C2DbC1dD3ff86CDcdcc4C",
        netName: "BSC",
        poolId: 1,
        swapAddress: "0x28ec0B36F0819ecB5005cAB836F4ED5a2eCa4D13",
        poolTokens: USDPoolTokens(Tokens.BUSD),
    });
    SwapPools.POLYGON_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.POLYGON,
        address: "0x7479e1bc2f2473f9e78c89b4210eb6d55d33b645",
        netName: "Polygon",
        poolId: 1,
        swapAddress: "0x85fCD7Dd0a1e1A9FCD5FD886ED522dE8221C3EE5",
        poolTokens: USDPoolTokens(),
    });
    SwapPools.FANTOM_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.FANTOM,
        address: "0x2DC777ff99058a12844A33D9B1AE6c8AB4701F66",
        netName: "Fantom",
        poolId: 3,
        swapAddress: "0x85662fd123280827e11C59973Ac9fcBE838dC3B4",
        poolTokens: USDPoolTokens(null),
    });
    SwapPools.FANTOM_ETH_SWAP_TOKEN = makeETHSwapToken({
        chainId: ChainId.FANTOM,
        address: "0x0e3dD3403ee498694A8f61B04AFed8919F747f77",
        netName: "Fantom",
        poolId: 2,
        swapAddress: "0x8D9bA570D6cb60C7e3e0F31343Efe75AB8E65FB1",
        poolTokens: ETHTokensPool(Tokens.FTM_ETH),
    });
    SwapPools.BOBA_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.BOBA,
        address: "0x9D7283A6AeeD9BCd4Ac70876fEA2b69a63DD8cb9",
        netName: "Boba",
        poolId: 1,
        swapAddress: "0x75FF037256b36F15919369AC58695550bE72fead",
        poolTokens: USDPoolTokens(),
    });
    SwapPools.BOBA_ETH_SWAP_TOKEN = makeETHSwapToken({
        chainId: ChainId.BOBA,
        address: "0x498657f2AF18D525049dE520dD86ee376Db9c67c",
        netName: "Boba",
        poolId: 2,
        swapAddress: "0x753bb855c8fe814233d26Bb23aF61cb3d2022bE5",
        swapETHAddress: "0x4F4f66964335D7bef23C16a62Fcd3d1E89f02959",
        poolTokens: WETHTokenPool,
        nativeTokens: ETHTokenPool,
    });
    SwapPools.METIS_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.METIS,
        address: "0xC6f684aE516480A35f337a4dA8b40EB6550e07E0",
        netName: "Metis",
        poolId: 0,
        swapAddress: "0x555982d2E211745b96736665e19D9308B615F78e",
        poolTokens: [Tokens.NUSD, Tokens.USDC],
    });
    SwapPools.METIS_ETH_SWAP_TOKEN = makeETHSwapToken({
        chainId: ChainId.METIS,
        address: "0x9C1340Bf093d057fA29819575517fb9fE2f04AcE",
        netName: "Metis",
        poolId: 1,
        swapAddress: "0x09fEC30669d63A13c666d2129230dD5588E2e240",
        poolTokens: ETHTokensPool(Tokens.METIS_ETH),
    });
    SwapPools.ARBITRUM_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.ARBITRUM,
        address: "0xcFd72be67Ee69A0dd7cF0f846Fc0D98C33d60F16",
        netName: "Arbitrum",
        poolId: 2,
        swapAddress: "0x9Dd329F5411466d9e0C488fF72519CA9fEf0cb40",
        poolTokens: USDPoolTokens(null),
    });
    SwapPools.ARBITRUM_ETH_SWAP_TOKEN = makeETHSwapToken({
        chainId: ChainId.ARBITRUM,
        address: "0xD70A52248e546A3B260849386410C7170c7BD1E9",
        netName: "Arbitrum",
        poolId: 0,
        swapAddress: "0xa067668661C84476aFcDc6fA5D758C4c01C34352",
        swapETHAddress: "0x1c3fe783a7c06bfAbd124F2708F5Cc51fA42E102",
        poolTokens: WETHTokenPool,
        nativeTokens: ETHTokenPool,
    });
    SwapPools.AVALANCHE_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.AVALANCHE,
        address: "0xCA87BF3ec55372D9540437d7a86a7750B42C02f4",
        netName: "Avalanche",
        poolId: 1,
        swapAddress: "0xED2a7edd7413021d440b09D654f3b87712abAB66",
        poolTokens: USDPoolTokens(),
    });
    var AVAX_AVWETH_POOLTOKENS = ETHTokensPool(Tokens.AVWETH), AVAX_WETHE_POOLTOKENS = ETHTokensPool(Tokens.WETH_E);
    SwapPools.AVALANCHE_ETH_SWAP_TOKEN = makeETHSwapToken({
        chainId: ChainId.AVALANCHE,
        address: "0x5dF1dB940dd8fEE0e0eB0C8917cb50b4dfaDF98c",
        netName: "Avalanche",
        poolId: 2,
        swapAddress: "0x77a7e60555bC18B4Be44C181b2575eee46212d44",
        swapETHAddress: "0xdd60483Ace9B215a7c019A44Be2F22Aa9982652E",
        poolTokens: AVAX_AVWETH_POOLTOKENS,
        nativeTokens: AVAX_WETHE_POOLTOKENS,
        depositTokens: AVAX_WETHE_POOLTOKENS,
    });
    SwapPools.AURORA_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.AURORA,
        address: "0xEAdC3524f3F007cdC5104BF28663b1141D3e3127",
        netName: "Aurora",
        poolId: 0,
        swapAddress: "0xcEf6C2e20898C2604886b888552CA6CcF66933B0",
        poolTokens: USDPoolTokens(null),
    });
    SwapPools.HARMONY_POOL_SWAP_TOKEN = makeSwapToken({
        chainId: ChainId.HARMONY,
        address: "0xE269abBFAF52b26D2632F55B6b223A5223088B96",
        netName: "Harmony",
        poolId: 1,
        swapAddress: "0x3ea9B0ab55F34Fb188824Ee288CeaEfC63cf908e",
        poolTokens: USDPoolTokens(),
    });
    var ONEETH_POOL_TOKENS = ETHTokensPool(Tokens.ONE_ETH);
    SwapPools.HARMONY_ONEETH_TOKEN = makeETHSwapToken({
        chainId: ChainId.HARMONY,
        address: "0x464d121D3cA63cEEfd390D76f19364D3Bd024cD2",
        netName: "Harmony",
        poolName: "1ETH",
        poolId: 1,
        swapAddress: "0x2913E812Cf0dcCA30FB28E6Cac3d2DCFF4497688",
        poolTokens: ONEETH_POOL_TOKENS,
        nativeTokens: ONEETH_POOL_TOKENS,
        depositTokens: ONEETH_POOL_TOKENS,
    });
    SwapPools.HARMONY_AVAX_SWAP_TOKEN = new SwapToken({
        chainId: ChainId.HARMONY,
        name: "AVAX LP Token Harmony ",
        symbol: "AVAXLP",
        decimals: 18,
        addresses: (_a = {},
            _a[ChainId.HARMONY] = "0x02f7D17f126BD54573c8EbAD9e05408A56f46452",
            _a),
        poolId: 0,
        poolType: SwapType.AVAX,
        poolName: "Harmony AVAX Swap Pool ",
        poolTokens: [Tokens.SYN_AVAX, Tokens.MULTI_AVAX],
        swapAddress: "0x00A4F57D926781f62D09bb05ec76e6D8aE4268da"
    });
    SwapPools.HARMONY_JEWEL_SWAP_TOKEN = new SwapToken({
        chainId: ChainId.HARMONY,
        name: "Jewel LP Token Harmony ",
        symbol: "JEWELP",
        decimals: 18,
        addresses: (_b = {},
            _b[ChainId.HARMONY] = "0x0000000000000000000000000000000000000000",
            _b),
        poolId: 0,
        poolType: SwapType.JEWEL,
        poolName: "Harmony Jewel Swap Pool ",
        poolTokens: [Tokens.JEWEL, Tokens.SYN_JEWEL],
        swapAddress: "0x7bE461cce1501f07969BCE24Ccb2140fCA0a35b3"
    });
    var makeSingleTokenPool = function (t) { return ({ poolTokens: [t], swapType: t.swapType }); };
    var ETH_Pool = makeSingleTokenPool(Tokens.ETH), SYN_Pool = makeSingleTokenPool(Tokens.SYN), FRAX_Pool = makeSingleTokenPool(Tokens.FRAX), HIGH_Pool = makeSingleTokenPool(Tokens.HIGH), DOG_Pool = makeSingleTokenPool(Tokens.DOG), JUMP_Pool = makeSingleTokenPool(Tokens.JUMP), NFD_Pool = makeSingleTokenPool(Tokens.NFD), GOHM_Pool = makeSingleTokenPool(Tokens.GOHM), GMX_Pool = makeSingleTokenPool(Tokens.GMX), SOLAR_Pool = makeSingleTokenPool(Tokens.SOLAR), AVAX_Pool = makeSingleTokenPool(Tokens.AVAX), WAVAX_Pool = makeSingleTokenPool(Tokens.WAVAX), MOVR_Pool = makeSingleTokenPool(Tokens.MOVR), WMOVR_Pool = makeSingleTokenPool(Tokens.WMOVR), UST_Pool = makeSingleTokenPool(Tokens.UST), NEWO_Pool = makeSingleTokenPool(Tokens.NEWO), SDT_Pool = makeSingleTokenPool(Tokens.SDT), LUNA_Pool = makeSingleTokenPool(Tokens.LUNA), USDB_Pool = makeSingleTokenPool(Tokens.USDB), DFK_USDC_Pool = makeSingleTokenPool(Tokens.DFK_USDC), XJEWEL_Pool = makeSingleTokenPool(Tokens.XJEWEL), VSTA_Pool = makeSingleTokenPool(Tokens.VSTA);
    var AVAX_JEWEL_Pool = { poolTokens: [Tokens.JEWEL, Tokens.MULTIJEWEL], swapType: SwapType.JEWEL }, DFK_JEWEL_Pool = { poolTokens: [Tokens.GAS_JEWEL, Tokens.JEWEL], swapType: SwapType.JEWEL }, HARMONY_JEWEL_Pool = { poolTokens: [Tokens.JEWEL, Tokens.SYN_JEWEL], swapType: SwapType.JEWEL };
    var makeSwapTypeMap = function (base) {
        var _a, _b;
        var pools = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            pools[_i - 1] = arguments[_i];
        }
        var m = {
            swappableTokens: (_a = {},
                _a[SwapType.SYN] = SYN_Pool.poolTokens,
                _a[SwapType.UST] = UST_Pool.poolTokens,
                _a[SwapType.OHM] = GOHM_Pool.poolTokens,
                _a),
            swappableSwapGroups: (_b = {},
                _b[SwapType.SYN] = SYN_Pool,
                _b[SwapType.UST] = UST_Pool,
                _b[SwapType.OHM] = GOHM_Pool,
                _b)
        };
        var _c = base.usdPool, usdPool = _c === void 0 ? null : _c, _d = base.ethPool, ethPool = _d === void 0 ? null : _d, _e = base.ohm, useOhm = _e === void 0 ? true : _e;
        if (usdPool) {
            m.swappableSwapGroups[SwapType.USD] = usdPool[0];
            m.swappableTokens[SwapType.USD] = usdPool[1];
        }
        if (ethPool) {
            m.swappableSwapGroups[SwapType.ETH] = ethPool[0];
            m.swappableTokens[SwapType.ETH] = ethPool[1];
        }
        for (var _f = 0, pools_1 = pools; _f < pools_1.length; _f++) {
            var p = pools_1[_f];
            m.swappableTokens[p.swapType] = p.poolTokens;
            m.swappableSwapGroups[p.swapType] = p;
        }
        if (!useOhm) {
            delete m.swappableTokens[SwapType.OHM];
            delete m.swappableSwapGroups[SwapType.OHM];
        }
        return m;
    };
    SwapPools.bridgeSwappableMap = (_c = {},
        _c[ChainId.ETH] = makeSwapTypeMap({
            usdPool: [
                SwapPools.ETH_POOL_SWAP_TOKEN,
                __spreadArray(__spreadArray([], SwapPools.ETH_POOL_SWAP_TOKEN.poolTokens, true), [Tokens.NUSD], false)
            ]
        }, ETH_Pool, HIGH_Pool, DOG_Pool, FRAX_Pool, NEWO_Pool, SDT_Pool, USDB_Pool, VSTA_Pool),
        _c[ChainId.OPTIMISM] = makeSwapTypeMap({
            usdPool: [SwapPools.OPTIMISM_POOL_SWAP_TOKEN, SwapPools.OPTIMISM_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.OPTIMISM_ETH_SWAP_TOKEN, SwapPools.OPTIMISM_ETH_SWAP_TOKEN.poolTokens]
        }, LUNA_Pool),
        _c[ChainId.CRONOS] = makeSwapTypeMap({
            usdPool: [SwapPools.CRONOS_POOL_SWAP_TOKEN, SwapPools.CRONOS_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps]
        }),
        _c[ChainId.BSC] = makeSwapTypeMap({
            usdPool: [SwapPools.BSC_POOL_SWAP_TOKEN, SwapPools.BSC_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps]
        }, HIGH_Pool, DOG_Pool, JUMP_Pool, NFD_Pool, USDB_Pool),
        _c[ChainId.POLYGON] = makeSwapTypeMap({
            usdPool: [SwapPools.POLYGON_POOL_SWAP_TOKEN, SwapPools.POLYGON_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps]
        }, NFD_Pool, DOG_Pool, USDB_Pool),
        _c[ChainId.FANTOM] = makeSwapTypeMap({
            usdPool: [SwapPools.FANTOM_POOL_SWAP_TOKEN, SwapPools.FANTOM_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.FANTOM_ETH_SWAP_TOKEN, SwapPools.FANTOM_ETH_SWAP_TOKEN.poolTokensForBridgeSwaps]
        }, JUMP_Pool, FRAX_Pool, SDT_Pool, USDB_Pool),
        _c[ChainId.BOBA] = makeSwapTypeMap({
            usdPool: [SwapPools.BOBA_POOL_SWAP_TOKEN, SwapPools.BOBA_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.BOBA_ETH_SWAP_TOKEN, SwapPools.BOBA_ETH_SWAP_TOKEN.poolTokens]
        }),
        _c[ChainId.METIS] = makeSwapTypeMap({
            usdPool: [SwapPools.METIS_POOL_SWAP_TOKEN, SwapPools.METIS_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.METIS_ETH_SWAP_TOKEN, SwapPools.METIS_ETH_SWAP_TOKEN.poolTokensForBridgeSwaps]
        }),
        _c[ChainId.MOONBEAM] = makeSwapTypeMap({}, SOLAR_Pool, WMOVR_Pool, WAVAX_Pool),
        _c[ChainId.MOONRIVER] = makeSwapTypeMap({}, SOLAR_Pool, FRAX_Pool, MOVR_Pool, USDB_Pool),
        _c[ChainId.ARBITRUM] = makeSwapTypeMap({
            usdPool: [SwapPools.ARBITRUM_POOL_SWAP_TOKEN, SwapPools.ARBITRUM_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.ARBITRUM_ETH_SWAP_TOKEN, SwapPools.ARBITRUM_ETH_SWAP_TOKEN.poolTokens]
        }, GMX_Pool, NEWO_Pool, LUNA_Pool, VSTA_Pool),
        _c[ChainId.AVALANCHE] = makeSwapTypeMap({
            usdPool: [SwapPools.AVALANCHE_POOL_SWAP_TOKEN, SwapPools.AVALANCHE_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.AVALANCHE_ETH_SWAP_TOKEN, SwapPools.AVALANCHE_ETH_SWAP_TOKEN.poolTokensForBridgeSwaps]
        }, NFD_Pool, GMX_Pool, AVAX_Pool, NEWO_Pool, SDT_Pool, USDB_Pool, AVAX_JEWEL_Pool),
        _c[ChainId.DFK] = {
            swappableTokens: (_d = {},
                _d[SwapType.USD] = DFK_USDC_Pool.poolTokens,
                _d[SwapType.JEWEL] = DFK_JEWEL_Pool.poolTokens,
                _d[SwapType.XJEWEL] = XJEWEL_Pool.poolTokens,
                _d[SwapType.AVAX] = WAVAX_Pool.poolTokens,
                _d),
            swappableSwapGroups: (_e = {},
                _e[SwapType.USD] = DFK_USDC_Pool,
                _e[SwapType.JEWEL] = DFK_JEWEL_Pool,
                _e[SwapType.XJEWEL] = XJEWEL_Pool,
                _e[SwapType.AVAX] = WAVAX_Pool,
                _e)
        },
        _c[ChainId.AURORA] = makeSwapTypeMap({
            usdPool: [SwapPools.AURORA_POOL_SWAP_TOKEN, SwapPools.AURORA_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ohm: false
        }),
        _c[ChainId.HARMONY] = makeSwapTypeMap({
            usdPool: [SwapPools.HARMONY_POOL_SWAP_TOKEN, SwapPools.HARMONY_POOL_SWAP_TOKEN.poolTokensForBridgeSwaps],
            ethPool: [SwapPools.HARMONY_ONEETH_TOKEN, SwapPools.HARMONY_ONEETH_TOKEN.poolTokensForBridgeSwaps]
        }, FRAX_Pool, SDT_Pool, SwapPools.HARMONY_AVAX_SWAP_TOKEN, XJEWEL_Pool, HARMONY_JEWEL_Pool),
        _c);
    function swapGroupsForChain(chainId) {
        return Object.values(SwapPools.bridgeSwappableMap[chainId].swappableSwapGroups).map(function (lp) { return lp.swapType; });
    }
    SwapPools.swapGroupsForChain = swapGroupsForChain;
    function tokensForChainBySwapGroup(chainId, swapGroup) {
        var m = SwapPools.bridgeSwappableMap[chainId].swappableTokens;
        return swapGroup in m ? m[swapGroup] : [];
    }
    SwapPools.tokensForChainBySwapGroup = tokensForChainBySwapGroup;
    function getAllSwappableTokensForNetwork(chainId) {
        var swappableTokens = [];
        swapGroupsForChain(chainId).forEach(function (grp) {
            var tokens = tokensForChainBySwapGroup(chainId, grp);
            swappableTokens = __spreadArray(__spreadArray([], swappableTokens, true), tokens, true);
        });
        return swappableTokens;
    }
    SwapPools.getAllSwappableTokensForNetwork = getAllSwappableTokensForNetwork;
    function stableswapPoolForNetwork(chainId) {
        switch (chainId) {
            case ChainId.ETH:
                return SwapPools.ETH_POOL_SWAP_TOKEN;
            case ChainId.OPTIMISM:
                return SwapPools.OPTIMISM_POOL_SWAP_TOKEN;
            case ChainId.CRONOS:
                return SwapPools.CRONOS_POOL_SWAP_TOKEN;
            case ChainId.BSC:
                return SwapPools.BSC_POOL_SWAP_TOKEN;
            case ChainId.POLYGON:
                return SwapPools.POLYGON_POOL_SWAP_TOKEN;
            case ChainId.FANTOM:
                return SwapPools.FANTOM_POOL_SWAP_TOKEN;
            case ChainId.BOBA:
                return SwapPools.BOBA_POOL_SWAP_TOKEN;
            case ChainId.METIS:
                return SwapPools.METIS_POOL_SWAP_TOKEN;
            case ChainId.ARBITRUM:
                return SwapPools.ARBITRUM_POOL_SWAP_TOKEN;
            case ChainId.AVALANCHE:
                return SwapPools.AVALANCHE_POOL_SWAP_TOKEN;
            case ChainId.AURORA:
                return SwapPools.AURORA_POOL_SWAP_TOKEN;
            case ChainId.HARMONY:
                return SwapPools.HARMONY_POOL_SWAP_TOKEN;
        }
        return undefined;
    }
    SwapPools.stableswapPoolForNetwork = stableswapPoolForNetwork;
    function ethSwapPoolForNetwork(chainId) {
        switch (chainId) {
            case ChainId.OPTIMISM:
                return SwapPools.OPTIMISM_ETH_SWAP_TOKEN;
            case ChainId.FANTOM:
                return SwapPools.FANTOM_ETH_SWAP_TOKEN;
            case ChainId.BOBA:
                return SwapPools.BOBA_ETH_SWAP_TOKEN;
            case ChainId.METIS:
                return SwapPools.METIS_ETH_SWAP_TOKEN;
            case ChainId.ARBITRUM:
                return SwapPools.ARBITRUM_ETH_SWAP_TOKEN;
            case ChainId.AVALANCHE:
                return SwapPools.AVALANCHE_ETH_SWAP_TOKEN;
            case ChainId.HARMONY:
                return SwapPools.HARMONY_ONEETH_TOKEN;
        }
        return undefined;
    }
    SwapPools.ethSwapPoolForNetwork = ethSwapPoolForNetwork;
    SwapPools.AllSwapPoolTokens = [
        SwapPools.ETH_POOL_SWAP_TOKEN,
        SwapPools.OPTIMISM_POOL_SWAP_TOKEN,
        SwapPools.OPTIMISM_ETH_SWAP_TOKEN,
        SwapPools.CRONOS_POOL_SWAP_TOKEN,
        SwapPools.BSC_POOL_SWAP_TOKEN,
        SwapPools.POLYGON_POOL_SWAP_TOKEN,
        SwapPools.FANTOM_POOL_SWAP_TOKEN,
        SwapPools.FANTOM_ETH_SWAP_TOKEN,
        SwapPools.BOBA_POOL_SWAP_TOKEN,
        SwapPools.BOBA_ETH_SWAP_TOKEN,
        SwapPools.METIS_POOL_SWAP_TOKEN,
        SwapPools.METIS_ETH_SWAP_TOKEN,
        SwapPools.ARBITRUM_POOL_SWAP_TOKEN,
        SwapPools.ARBITRUM_ETH_SWAP_TOKEN,
        SwapPools.AVALANCHE_POOL_SWAP_TOKEN,
        SwapPools.AVALANCHE_ETH_SWAP_TOKEN,
        SwapPools.AURORA_POOL_SWAP_TOKEN,
        SwapPools.HARMONY_POOL_SWAP_TOKEN,
        SwapPools.HARMONY_ONEETH_TOKEN,
        SwapPools.HARMONY_AVAX_SWAP_TOKEN,
        SwapPools.HARMONY_JEWEL_SWAP_TOKEN,
    ];
    function checkChainId(t, chainId) {
        if (typeof chainId !== 'undefined' && chainId !== null) {
            return chainId === t.chainId;
        }
        return true;
    }
    var CheckAddressKind;
    (function (CheckAddressKind) {
        CheckAddressKind[CheckAddressKind["LpTokenAddress"] = 0] = "LpTokenAddress";
        CheckAddressKind[CheckAddressKind["SwapAddress"] = 1] = "SwapAddress";
    })(CheckAddressKind || (CheckAddressKind = {}));
    function checkSwapPoolTokenAddress(address, field, chainId) {
        var res = null;
        for (var _i = 0, AllSwapPoolTokens_1 = SwapPools.AllSwapPoolTokens; _i < AllSwapPoolTokens_1.length; _i++) {
            var t = AllSwapPoolTokens_1[_i];
            var checkAddress = void 0;
            switch (field) {
                case CheckAddressKind.LpTokenAddress:
                    checkAddress = t.address(t.chainId);
                    break;
                case CheckAddressKind.SwapAddress:
                    checkAddress = t.swapAddress;
                    break;
            }
            if (checkAddress === address) {
                if (checkChainId(t, chainId)) {
                    res = t;
                    break;
                }
            }
        }
        return res;
    }
    function swapPoolTokenFromLPTokenAddress(lpTokenAddress, chainId) {
        return checkSwapPoolTokenAddress(lpTokenAddress, CheckAddressKind.LpTokenAddress, chainId);
    }
    SwapPools.swapPoolTokenFromLPTokenAddress = swapPoolTokenFromLPTokenAddress;
    function swapPoolTokenFromSwapAddress(swapAddress, chainId) {
        return checkSwapPoolTokenAddress(swapAddress, CheckAddressKind.SwapAddress, chainId);
    }
    SwapPools.swapPoolTokenFromSwapAddress = swapPoolTokenFromSwapAddress;
    function swapPoolTokenForTypeForChain(chainId, swapType) {
        var res = null;
        for (var _i = 0, _a = swapPoolTokensForChainId(chainId); _i < _a.length; _i++) {
            var t = _a[_i];
            if (t.swapType === swapType) {
                res = t;
                break;
            }
        }
        return res;
    }
    SwapPools.swapPoolTokenForTypeForChain = swapPoolTokenForTypeForChain;
    function swapPoolTokensForChainId(chainId) {
        var res = [];
        SwapPools.AllSwapPoolTokens.forEach(function (t) {
            if (t.chainId === chainId) {
                res.push(t);
            }
        });
        return res;
    }
    SwapPools.swapPoolTokensForChainId = swapPoolTokensForChainId;
})(SwapPools || (SwapPools = {}));
function filterGrps(chainAGrps, chainBGrpsMap) {
    var tokens = [];
    Object.keys(chainBGrpsMap).forEach(function (grp) {
        if (chainAGrps.includes(grp)) {
            tokens = __spreadArray(__spreadArray([], tokens, true), chainBGrpsMap[grp].poolTokens, true);
        }
    });
    return tokens;
}
function swapGroupsLoop(chainIdA, swapGrps) {
    var res = {};
    supportedChainIds().forEach(function (chainId) {
        if (chainIdA === chainId) {
            return;
        }
        res[chainId] = filterGrps(swapGrps, SwapPools.bridgeSwappableMap[chainId].swappableSwapGroups);
    });
    return res;
}
/**
 * Returns a map of swappable tokens for two given networks; or, if a second chainid isn't passed,
 * a map of all swappable tokens for the passed chainid between all supported networks.
 * @param chainIdA
 * @param chainIdB Optional second network; if passed, a map of swappable tokens between ONLY chainIdA and chainIdB is returned.
 * @return NetworkSwappableTokensMap
 */
export function networkSwapTokensMap(chainIdA, chainIdB) {
    var res = {};
    var swapGrpsA = SwapPools.swapGroupsForChain(chainIdA);
    if (typeof chainIdB !== 'undefined') {
        res[chainIdB] = filterGrps(swapGrpsA, SwapPools.bridgeSwappableMap[chainIdB].swappableSwapGroups);
    }
    else {
        res = swapGroupsLoop(chainIdA, swapGrpsA);
    }
    return res;
}
/**
 * Returns map of all swappable tokens between all supported networks.
 * @return AllNetworksSwappableTokensMap
 */
export function allNetworksSwapTokensMap() {
    var res = {};
    supportedChainIds().forEach(function (chainIdA) {
        var swapGrpsA = SwapPools.swapGroupsForChain(chainIdA);
        res[chainIdA] = swapGroupsLoop(chainIdA, swapGrpsA);
    });
    return res;
}
