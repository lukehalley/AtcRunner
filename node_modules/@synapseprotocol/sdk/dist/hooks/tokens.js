var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Tokens } from "../tokens.js";
import { ERC20, MAX_APPROVAL_AMOUNT } from "../bridge/erc20.js";
import { useSignerFromEthereum } from "./signer.js";
import { logError, parseApproveAmount } from "./helpers.js";
import { AllowanceError, TransactionError } from "./errors.js";
import { useEffect, useState } from "react";
import { BigNumber } from "@ethersproject/bignumber";
var TX_STATUS_SUCCESS = 1;
function useCheckAllowance(ethereum, chainId) {
    var getSigner = useSignerFromEthereum()[0];
    var _a = useState(null), allowance = _a[0], setAllowance = _a[1];
    function fn(args) {
        getSigner(ethereum).getAddress()
            .then(function (ownerAddress) {
            var token = args.token, spender = args.spender;
            var tokenArgs = { tokenAddress: token.address(chainId), chainId: chainId };
            ERC20.allowanceOf(ownerAddress, spender, tokenArgs)
                .then(setAllowance)
                .catch(function (e) {
                var err = e instanceof Error ? e : new Error(e);
                var allowanceErr = new AllowanceError(ownerAddress, spender, token, "exception thrown from ERC20.allowanceOf()", err);
                console.error(allowanceErr);
                console.error(allowanceErr.cause);
            });
        });
    }
    return [fn, allowance];
}
function useApproveTokenSpend(ethereum, chainId) {
    var getSigner = useSignerFromEthereum()[0];
    var _a = useState(null), tx = _a[0], setTx = _a[1];
    function fn(args) {
        Tokens.approveTokenSpend(__assign(__assign({}, args), { amount: parseApproveAmount(args.amount, args.token, chainId), chainId: chainId, signer: getSigner(ethereum) }))
            .then(setTx)
            .catch(logError);
    }
    return [fn, tx];
}
function useApproveStatus(ethereum, chainId) {
    var _a = useState(false), approveComplete = _a[0], setApproveComplete = _a[1];
    var _b = useState(null), approveState = _b[0], setApproveState = _b[1];
    function fn(args) {
        if (approveComplete) {
            return;
        }
        var token = args.token, spender = args.spender, amount = args.amount, approveTx = args.approveTx;
        var wantAmt = amount ? parseApproveAmount(amount, token, chainId) : MAX_APPROVAL_AMOUNT;
        if (!approveTx) {
            return;
        }
        var txHash = approveTx.hash;
        var confirmations = approveTx.confirmations;
        if (confirmations >= 1) {
            setApproveState({
                token: token,
                spender: spender,
                amount: wantAmt
            });
            return;
        }
        approveTx.wait(1)
            .then(function (txResult) {
            var txStatus = txResult.status;
            if (txStatus) {
                if (txStatus !== TX_STATUS_SUCCESS) {
                    var txErr = new TransactionError(txHash, "reverted");
                    console.error(txErr);
                    return;
                }
            }
            setApproveState({
                token: token,
                spender: spender,
                amount: wantAmt
            });
        })
            .catch(function (e) {
            var err = e instanceof Error ? e : new Error(e);
            var txErr = new TransactionError(txHash, "exception thrown from .wait(1)", err);
            console.error(txErr);
            console.error(txErr.cause);
        });
    }
    var _c = useCheckAllowance(ethereum, chainId), checkAllowance = _c[0], allowance = _c[1];
    var _d = useState(false), checkFired = _d[0], setCheckFired = _d[1];
    useEffect(function () {
        if (!checkFired && approveState) {
            checkAllowance(approveState);
            setCheckFired(true);
        }
    }, [checkFired, approveState]);
    useEffect(function () {
        if (allowance && approveState) {
            var checkAmt = BigNumber.from(approveState.amount);
            if (MAX_APPROVAL_AMOUNT.eq(approveState.amount)) {
                checkAmt = MAX_APPROVAL_AMOUNT.sub(5);
            }
            if (allowance.gte(checkAmt)) {
                setApproveComplete(true);
            }
        }
    }, [allowance, approveState]);
    return [fn, approveComplete, allowance];
}
export { TransactionError, AllowanceError, useApproveTokenSpend, useApproveStatus, useCheckAllowance };
