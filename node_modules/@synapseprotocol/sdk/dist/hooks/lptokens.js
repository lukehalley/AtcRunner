var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { isArray } from "lodash-es";
import { SwapPools } from "../swappools.js";
import { TokenSwap } from "../tokenswap.js";
import { useSignerFromEthereum } from "./signer.js";
import { useApproveStatus, useApproveTokenSpend, useCheckAllowance } from "./tokens.js";
import { logError, parseBigNumberish, parseLPTokenBigNumberishArray } from "./helpers.js";
import { useEffect, useState } from "react";
import { BigNumber } from "@ethersproject/bignumber";
/**
 * Returns the Stableswap LP token object for a given Chain ID, if one exists.
 *
 * @param ethereum
 * @param chainId
 *
 * @return Single-item array containing LP token object
 */
function useChainStableswapLPToken(ethereum, chainId) {
    var _a = useState(null), lpToken = _a[0], setLpToken = _a[1];
    useEffect(function () {
        if (typeof chainId !== 'undefined' && chainId !== null) {
            setLpToken(SwapPools.stableswapPoolForNetwork(chainId));
        }
    }, [chainId]);
    return [lpToken];
}
/**
 * Returns the ETHSwap LP token object for a given Chain ID, if one exists.
 *
 * @param ethereum
 * @param chainId
 *
 * @return Single-item array containing LP token object
 */
function useChainETHSwapLPToken(ethereum, chainId) {
    var _a = useState(null), lpToken = _a[0], setLpToken = _a[1];
    useEffect(function () {
        if (typeof chainId !== 'undefined' && chainId !== null) {
            if (lpToken !== null) {
                if (lpToken.chainId !== chainId) {
                    setLpToken(SwapPools.ethSwapPoolForNetwork(chainId));
                }
            }
            else {
                setLpToken(SwapPools.ethSwapPoolForNetwork(chainId));
            }
        }
    }, [chainId]);
    return [lpToken];
}
function useHarmonyJewelLPToken() {
    return [SwapPools.HARMONY_JEWEL_SWAP_TOKEN];
}
function useHarmonyAVAXLPToken() {
    return [SwapPools.HARMONY_AVAX_SWAP_TOKEN];
}
function useCalculateAddLiquidity(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var _a = useState(null), amount = _a[0], setAmount = _a[1];
    function fn() {
        var amounts = rest.amounts, lpToken = rest.lpToken;
        var amountsArray;
        if (isArray(amounts)) {
            var amts = amounts;
            amountsArray = parseLPTokenBigNumberishArray(lpToken, amts, chainId);
        }
        else {
            amountsArray = lpToken.liquidityAmountsFromMap(amounts);
        }
        TokenSwap.calculateAddLiquidity(__assign(__assign({}, rest), { amounts: amountsArray, chainId: chainId }))
            .then(setAmount)
            .catch(logError);
    }
    return [fn, amount];
}
function useCalculateRemoveLiquidity(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var _a = useState(null), amounts = _a[0], setAmounts = _a[1];
    function fn() {
        var amount = rest.amount, baseToken = rest.lpToken.baseToken;
        TokenSwap.calculateRemoveLiquidity(__assign(__assign({}, rest), { amount: parseBigNumberish(amount, baseToken, chainId), chainId: chainId }))
            .then(setAmounts)
            .catch(logError);
    }
    return [fn, amounts];
}
function useCalculateRemoveLiquidityOneToken(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var _a = useState(null), amount = _a[0], setAmount = _a[1];
    function fn() {
        TokenSwap.calculateRemoveLiquidityOneToken(__assign(__assign({}, rest), { amount: parseBigNumberish(rest.amount, rest.token, chainId), chainId: chainId }))
            .then(setAmount)
            .catch(logError);
    }
    return [fn, amount];
}
function useAddLiquidity(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var getSigner = useSignerFromEthereum()[0];
    var _a = useState(null), tx = _a[0], setTx = _a[1];
    function fn() {
        var amounts = rest.amounts, lpToken = rest.lpToken;
        var amountsArray;
        if (isArray(amounts)) {
            var amts = amounts;
            amountsArray = parseLPTokenBigNumberishArray(lpToken, amts, chainId);
        }
        else {
            amountsArray = lpToken.liquidityAmountsFromMap(amounts);
        }
        TokenSwap.addLiquidity(__assign(__assign({}, rest), { chainId: chainId, signer: getSigner(ethereum), amounts: amountsArray, deadline: BigNumber.from(rest.deadline), minToMint: parseBigNumberish(rest.minToMint, rest.lpToken.baseToken, chainId) }))
            .then(setTx)
            .catch(logError);
    }
    return [fn, tx];
}
function useRemoveLiquidity(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var getSigner = useSignerFromEthereum()[0];
    var _a = useState(null), tx = _a[0], setTx = _a[1];
    function fn() {
        var minAmounts = rest.minAmounts, lpToken = rest.lpToken;
        var minAmountsArray;
        if (isArray(minAmounts)) {
            var amts = minAmounts;
            minAmountsArray = parseLPTokenBigNumberishArray(lpToken, amts, chainId);
        }
        else {
            minAmountsArray = lpToken.liquidityAmountsFromMap(minAmounts);
        }
        TokenSwap.removeLiquidity(__assign(__assign({}, rest), { chainId: chainId, minAmounts: minAmountsArray, signer: getSigner(ethereum), amount: parseBigNumberish(rest.amount, rest.lpToken.baseToken, chainId), deadline: BigNumber.from(rest.deadline) }))
            .then(setTx)
            .catch(logError);
    }
    return [fn, tx];
}
function useRemoveLiquidityOneToken(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var getSigner = useSignerFromEthereum()[0];
    var _a = useState(null), tx = _a[0], setTx = _a[1];
    function fn() {
        TokenSwap.removeLiquidityOneToken(__assign(__assign({}, rest), { chainId: chainId, signer: getSigner(ethereum), amount: parseBigNumberish(rest.amount, rest.token, chainId), minAmount: parseBigNumberish(rest.minAmount, rest.lpToken.baseToken, chainId), deadline: BigNumber.from(rest.deadline) }))
            .then(setTx)
            .catch(logError);
    }
    return [fn, tx];
}
function useCalculateSwapRate(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var _a = useState(null), swapRate = _a[0], setSwapRate = _a[1];
    function fn() {
        TokenSwap.calculateSwapRate(__assign(__assign({}, rest), { chainId: chainId, amountIn: parseBigNumberish(rest.amountIn, rest.tokenFrom, chainId) }))
            .then(function (res) { return setSwapRate(res.amountOut); })
            .catch(logError);
    }
    return [fn, swapRate];
}
function useSwapTokens(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var getSigner = useSignerFromEthereum()[0];
    var _a = useState(null), tx = _a[0], setTx = _a[1];
    function fn() {
        var fnParams = __assign(__assign({}, rest), { chainId: chainId, signer: getSigner(ethereum), amountIn: parseBigNumberish(rest.amountIn, rest.tokenFrom, chainId), minAmountOut: parseBigNumberish(rest.minAmountOut, rest.tokenTo, chainId) });
        TokenSwap.swapTokens(fnParams)
            .then(setTx)
            .catch(logError);
    }
    return [fn, tx];
}
function useApproveLPToken(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var _a = useApproveTokenSpend(ethereum, chainId), approveSpend = _a[0], approveTx = _a[1], _b = useApproveStatus(ethereum, chainId), queryApproveStatus = _b[0], approveStatus = _b[1];
    var _c = useState(null), approveData = _c[0], setApproveData = _c[1];
    function fn() {
        var amount = rest.amount, _a = rest.lpToken, spender = _a.swapAddress, token = _a.baseToken;
        approveSpend({ token: token, spender: spender });
        setApproveData({ token: token, spender: spender, amount: amount });
    }
    useEffect(function () {
        if (approveStatus !== null) {
            return;
        }
        if (approveTx && approveData) {
            var token = approveData.token, spender = approveData.spender, amount = approveData.amount;
            queryApproveStatus({
                token: token,
                spender: spender,
                amount: amount,
                approveTx: approveTx
            });
        }
    }, [approveTx, approveData, approveStatus]);
    return [fn, approveTx, approveStatus];
}
function useApprovePoolToken(args) {
    var ethereum = args.ethereum, chainId = args.chainId, rest = __rest(args, ["ethereum", "chainId"]);
    var _a = useApproveTokenSpend(ethereum, chainId), approveSpend = _a[0], approveTx = _a[1], _b = useApproveStatus(ethereum, chainId), queryApproveStatus = _b[0], approveStatus = _b[1];
    var _c = useState(null), approveData = _c[0], setApproveData = _c[1];
    function fn() {
        var amount = rest.amount, token = rest.token, spender = rest.lpToken.swapAddress;
        Promise.resolve(approveSpend({ token: token, spender: spender }))
            .then(function () {
            setApproveData({ token: token, spender: spender, amount: amount });
        });
    }
    useEffect(function () {
        if (approveStatus !== null) {
            return;
        }
        if (approveTx && approveData) {
            var token = approveData.token, spender = approveData.spender, amount = approveData.amount;
            queryApproveStatus({
                token: token,
                spender: spender,
                amount: amount,
                approveTx: approveTx
            });
        }
    }, [approveTx, approveData, approveStatus]);
    return [fn, approveTx, approveStatus];
}
function useLPTokenAllowance(args) {
    var ethereum = args.ethereum, chainId = args.chainId, lpToken = args.lpToken;
    var _a = useCheckAllowance(ethereum, chainId), checkAllowance = _a[0], allowance = _a[1];
    useEffect(function () {
        if (lpToken) {
            var token = lpToken.baseToken, spender = lpToken.swapAddress;
            checkAllowance({ token: token, spender: spender });
        }
    }, [chainId, lpToken]);
    return [allowance];
}
function useLPTokenNeedsApproval(args) {
    var chainId = args.chainId, amount = args.amount, lpToken = args.lpToken;
    var allowance = useLPTokenAllowance(args)[0];
    var _a = useState(null), needsApprove = _a[0], setNeedsApprove = _a[1];
    useEffect(function () {
        if (allowance && amount && lpToken) {
            var token = lpToken.baseToken;
            var amt = parseBigNumberish(amount, token, chainId);
            setNeedsApprove(allowance.lt(amt));
        }
    }, [allowance, chainId, lpToken, amount]);
    return [needsApprove, allowance];
}
function useLPTokenApproval(args) {
    var _a = useLPTokenNeedsApproval(args), needsApprove = _a[0], allowance = _a[1];
    var _b = useApproveLPToken(__assign(__assign({}, args), { amount: undefined })), execApprove = _b[0], approveTx = _b[1], approveStatus = _b[2];
    return {
        needsApprove: needsApprove,
        allowance: allowance,
        execApprove: execApprove,
        approveTx: approveTx,
        approveStatus: approveStatus
    };
}
function usePoolTokenAllowance(args) {
    var ethereum = args.ethereum, chainId = args.chainId, lpToken = args.lpToken, token = args.token;
    var _a = useCheckAllowance(ethereum, chainId), checkAllowance = _a[0], allowance = _a[1];
    useEffect(function () {
        if (lpToken) {
            var spender = lpToken.swapAddress;
            checkAllowance({ token: token, spender: spender });
        }
    }, [chainId, token, lpToken]);
    return [allowance];
}
function usePoolTokenNeedsApproval(args) {
    var chainId = args.chainId, token = args.token, amount = args.amount, lpToken = args.lpToken;
    var allowance = usePoolTokenAllowance(args)[0];
    var _a = useState(null), needsApprove = _a[0], setNeedsApprove = _a[1];
    useEffect(function () {
        if (allowance && amount) {
            var amt = parseBigNumberish(amount, token, chainId);
            setNeedsApprove(allowance.lt(amt));
        }
    }, [allowance, chainId, token, amount, lpToken]);
    return [needsApprove, allowance];
}
function usePoolTokenApproval(args) {
    var _a = usePoolTokenNeedsApproval(args), needsApprove = _a[0], allowance = _a[1];
    var _b = useApprovePoolToken(__assign(__assign({}, args), { amount: undefined })), execApprove = _b[0], approveTx = _b[1], approveStatus = _b[2];
    return {
        needsApprove: needsApprove,
        allowance: allowance,
        execApprove: execApprove,
        approveTx: approveTx,
        approveStatus: approveStatus
    };
}
export { useChainStableswapLPToken, useChainETHSwapLPToken, useHarmonyJewelLPToken, useHarmonyAVAXLPToken, useCalculateAddLiquidity, useCalculateRemoveLiquidity, useCalculateRemoveLiquidityOneToken, useAddLiquidity, useRemoveLiquidity, useRemoveLiquidityOneToken, useCalculateSwapRate, useSwapTokens, useApproveLPToken, useApprovePoolToken, useLPTokenAllowance, useLPTokenNeedsApproval, useLPTokenApproval, usePoolTokenAllowance, usePoolTokenNeedsApproval, usePoolTokenApproval };
