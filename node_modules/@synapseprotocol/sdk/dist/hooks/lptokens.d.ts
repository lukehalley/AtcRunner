import type { Token } from "../token";
import { SwapPools } from "../swappools";
import type { AllowanceHook } from "./types";
import { BigNumber, type BigNumberish } from "@ethersproject/bignumber";
import type { ContractTransaction } from "@ethersproject/contracts";
import { ApproveActionHook, NeedsApprovalHook, UseApproveHook } from "./types";
/**
 * Returns the Stableswap LP token object for a given Chain ID, if one exists.
 *
 * @param ethereum
 * @param chainId
 *
 * @return Single-item array containing LP token object
 */
declare function useChainStableswapLPToken(ethereum: any, chainId: number): readonly [SwapPools.SwapPoolToken];
/**
 * Returns the ETHSwap LP token object for a given Chain ID, if one exists.
 *
 * @param ethereum
 * @param chainId
 *
 * @return Single-item array containing LP token object
 */
declare function useChainETHSwapLPToken(ethereum: any, chainId: number): readonly [SwapPools.SwapPoolToken];
declare function useHarmonyJewelLPToken(): readonly [SwapPools.SwapToken];
declare function useHarmonyAVAXLPToken(): readonly [SwapPools.SwapToken];
declare function useCalculateAddLiquidity(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    amounts: BigNumberish[] | SwapPools.PoolTokensAmountsMap;
}): readonly [() => void, BigNumber];
declare function useCalculateRemoveLiquidity(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    amount: BigNumberish;
}): readonly [() => void, BigNumber[]];
declare function useCalculateRemoveLiquidityOneToken(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    token: Token;
    amount: BigNumberish;
}): readonly [() => void, BigNumber];
declare function useAddLiquidity(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    deadline: BigNumberish;
    amounts: BigNumberish[] | SwapPools.PoolTokensAmountsMap;
    minToMint: BigNumberish;
}): readonly [() => void, ContractTransaction];
declare function useRemoveLiquidity(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    deadline: BigNumberish;
    amount: BigNumberish;
    minAmounts: BigNumberish[] | SwapPools.PoolTokensAmountsMap;
}): readonly [() => void, ContractTransaction];
declare function useRemoveLiquidityOneToken(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    deadline: BigNumberish;
    amount: BigNumberish;
    minAmount: BigNumberish;
    token: Token;
}): readonly [() => void, ContractTransaction];
declare function useCalculateSwapRate(args: {
    ethereum: any;
    chainId: number;
    tokenFrom: Token;
    tokenTo: Token;
    amountIn: BigNumberish;
}): readonly [() => void, BigNumber];
declare function useSwapTokens(args: {
    ethereum: any;
    chainId: number;
    tokenFrom: Token;
    tokenTo: Token;
    amountIn: BigNumberish;
    minAmountOut: BigNumberish;
    deadline?: number;
}): readonly [() => void, ContractTransaction];
declare function useApproveLPToken(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    amount?: BigNumberish;
}): readonly [() => void, ContractTransaction, boolean];
declare function useApprovePoolToken(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    token: Token;
    amount?: BigNumberish;
}): ApproveActionHook;
declare function useLPTokenAllowance(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
}): readonly [BigNumber];
declare function useLPTokenNeedsApproval(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    amount: BigNumberish;
}): readonly [boolean, BigNumber];
declare function useLPTokenApproval(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    amount: BigNumberish;
}): {
    readonly needsApprove: boolean;
    readonly allowance: BigNumber;
    readonly execApprove: () => void;
    readonly approveTx: ContractTransaction;
    readonly approveStatus: boolean;
};
declare function usePoolTokenAllowance(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    token: Token;
}): AllowanceHook;
declare function usePoolTokenNeedsApproval(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    token: Token;
    amount: BigNumberish;
}): NeedsApprovalHook;
declare function usePoolTokenApproval(args: {
    ethereum: any;
    chainId: number;
    lpToken: SwapPools.SwapPoolToken;
    token: Token;
    amount: BigNumberish;
}): UseApproveHook;
export { useChainStableswapLPToken, useChainETHSwapLPToken, useHarmonyJewelLPToken, useHarmonyAVAXLPToken, useCalculateAddLiquidity, useCalculateRemoveLiquidity, useCalculateRemoveLiquidityOneToken, useAddLiquidity, useRemoveLiquidity, useRemoveLiquidityOneToken, useCalculateSwapRate, useSwapTokens, useApproveLPToken, useApprovePoolToken, useLPTokenAllowance, useLPTokenNeedsApproval, useLPTokenApproval, usePoolTokenAllowance, usePoolTokenNeedsApproval, usePoolTokenApproval };
