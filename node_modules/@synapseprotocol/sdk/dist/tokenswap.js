var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import _ from "lodash";
import { ChainId, supportedChainIds } from "./common/chainid.js";
import { Networks } from "./common/networks.js";
import { Tokens } from "./tokens.js";
import { SwapPools } from "./swappools.js";
import { rejectPromise } from "./common/utils.js";
import { BridgeConfigV3ContractInstance } from "./entities.js";
import { SwapFactory } from "./contracts.js";
import { SwapType, mintBurnSwapTypes } from "./internal/swaptype.js";
import { rpcProviderForChain } from "./internal/rpcproviders.js";
import { BigNumber } from "@ethersproject/bignumber";
import { makeTransactionGasOverrides, populateGasOptions } from "./common/gasoptions.js";
export var UnsupportedSwapErrors;
(function (UnsupportedSwapErrors) {
    var UnsupportedSwapErrorKind;
    (function (UnsupportedSwapErrorKind) {
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedToken"] = 0] = "UnsupportedToken";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedTokenNetFrom"] = 1] = "UnsupportedTokenNetFrom";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedTokenNetTo"] = 2] = "UnsupportedTokenNetTo";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["NonmatchingSwapTypes"] = 3] = "NonmatchingSwapTypes";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedMultiJEWELMigration"] = 4] = "UnsupportedMultiJEWELMigration";
    })(UnsupportedSwapErrorKind = UnsupportedSwapErrors.UnsupportedSwapErrorKind || (UnsupportedSwapErrors.UnsupportedSwapErrorKind = {}));
    var UnsupportedSwapError = /** @class */ (function (_super) {
        __extends(UnsupportedSwapError, _super);
        function UnsupportedSwapError(_a) {
            var reason = _a.reason, errorKind = _a.errorKind;
            var _this = _super.call(this, reason) || this;
            _this.name = _this.constructor.name;
            Error.captureStackTrace(_this, _this.constructor);
            _this.reason = reason;
            _this.errorKind = errorKind;
            return _this;
        }
        return UnsupportedSwapError;
    }(Error));
    UnsupportedSwapErrors.UnsupportedSwapError = UnsupportedSwapError;
    UnsupportedSwapErrors.tokenNotSupported = function (t, netName) { return new UnsupportedSwapError({
        reason: "Token ".concat(t.symbol, " not supported on network ").concat(netName),
        errorKind: UnsupportedSwapErrorKind.UnsupportedToken,
    }); };
    UnsupportedSwapErrors.tokenNotSupportedNetFrom = function (t, netName) { return new UnsupportedSwapError({
        reason: "Token ".concat(t.symbol, " not supported on 'from' network ").concat(netName),
        errorKind: UnsupportedSwapErrorKind.UnsupportedTokenNetFrom,
    }); };
    UnsupportedSwapErrors.tokenNotSupportedNetTo = function (t, netName) { return new UnsupportedSwapError({
        reason: "Token ".concat(t.symbol, " not supported on 'to' network ").concat(netName),
        errorKind: UnsupportedSwapErrorKind.UnsupportedTokenNetTo,
    }); };
    UnsupportedSwapErrors.nonMatchingSwapTypes = function () { return new UnsupportedSwapError({
        reason: "Token swap types don't match",
        errorKind: UnsupportedSwapErrorKind.NonmatchingSwapTypes,
    }); };
    UnsupportedSwapErrors.unsupportedMultiJEWELMigration = function () { return new UnsupportedSwapError({
        reason: "Migrating multiJEWEL from Avalanche to Harmony is not supported",
        errorKind: UnsupportedSwapErrorKind.UnsupportedMultiJEWELMigration,
    }); };
})(UnsupportedSwapErrors || (UnsupportedSwapErrors = {}));
export var TokenSwap;
(function (TokenSwap) {
    var _a;
    var BRIDGE_CONFIG_INSTANCE = BridgeConfigV3ContractInstance();
    var CHAIN_SWAPS_GAS_LIMITS = (_a = {},
        _a[ChainId.AVALANCHE] = { gasLimit: BigNumber.from("165000") },
        _a);
    function swapSupported(args) {
        var tokenFrom = args.tokenFrom, tokenTo = args.tokenTo, chainId = args.chainId;
        return checkCanSwap(tokenFrom, tokenTo, chainId);
    }
    TokenSwap.swapSupported = swapSupported;
    function bridgeSwapSupported(args) {
        var tokenFrom = args.tokenFrom, tokenTo = args.tokenTo, chainIdFrom = args.chainIdFrom, chainIdTo = args.chainIdTo;
        return checkCanSwap(tokenFrom, tokenTo, chainIdFrom, chainIdTo);
    }
    TokenSwap.bridgeSwapSupported = bridgeSwapSupported;
    /**
     * calculateAddLiquidity returns the estimated number of LP tokens which a user would receive
     * were they to deposit a given number of liquidity tokens into a pool.
     *
     * @param {AddLiquidityParams} args {@link AddLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {BigNumber[]} args.amounts Pool-index-relative array of token amounts to add as liquidity to the pool.
     *
     * @return {BigNumber} Amount of LP tokens a user would receive if the deposited liquidity tokens into the pool.
     */
    function calculateAddLiquidity(args) {
        return __awaiter(this, void 0, void 0, function () {
            var swapInstance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, swapContractFromLPSwapAddress(args.lpToken.swapAddress, args.chainId)];
                    case 1:
                        swapInstance = _a.sent();
                        return [2 /*return*/, swapInstance.calculateTokenAmount(args.amounts, true)];
                }
            });
        });
    }
    TokenSwap.calculateAddLiquidity = calculateAddLiquidity;
    /**
     * calculateRemoveLiquidity returns the estimated number of pooled tokens which a user would receive
     * were they to return some amount of their LP tokens to the Pool.
     *
     * @param {RemoveLiquidityParams} args {@link RemoveLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for pooled liquidity tokens.
     *
     * @return {BigNumber[]} Pool-index-relative array of token amounts which a user would receive if they remove the passed amount of LP tokens.
     */
    function calculateRemoveLiquidity(args) {
        return __awaiter(this, void 0, void 0, function () {
            var swapInstance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, swapContractFromLPSwapAddress(args.lpToken.swapAddress, args.chainId)];
                    case 1:
                        swapInstance = _a.sent();
                        return [2 /*return*/, swapInstance.calculateRemoveLiquidity(args.amount)];
                }
            });
        });
    }
    TokenSwap.calculateRemoveLiquidity = calculateRemoveLiquidity;
    /**
     * calculateRemoveLiquidityOneToken returns the estimated number of a single pooled token
     * which would be removed from a Liquidity Pool and transferred to a user
     * were they to return some amount of their LP tokens to the Pool.
     *
     * @param {RemoveLiquidityOneParams} args {@link RemoveLiquidityOneParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {Token} args.token Token which will be removed as liquidity from the Liquidity Pool and transferred to the user in exchange for their LP tokens.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for desired pooled liquidity token.
     *
     * @return {BigNumber} Amount of a single pooled liquidity token which would be removed from the Liquidity Pool and transferred to the user.
     */
    function calculateRemoveLiquidityOneToken(args) {
        return __awaiter(this, void 0, void 0, function () {
            var swapInstance, tokenAddress, err, tokenIndex, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, swapContractFromLPSwapAddress(args.lpToken.swapAddress, args.chainId)];
                    case 1:
                        swapInstance = _a.sent();
                        tokenAddress = args.token.address(args.chainId);
                        if (!tokenAddress) {
                            err = new Error("no address for token ".concat(args.token.name, " found for chain id ").concat(args.chainId));
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, swapInstance.getTokenIndex(tokenAddress)];
                    case 3:
                        tokenIndex = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        return [2 /*return*/, rejectPromise(e_1)];
                    case 5: return [2 /*return*/, swapInstance.calculateRemoveLiquidityOneToken(args.amount, tokenIndex)];
                }
            });
        });
    }
    TokenSwap.calculateRemoveLiquidityOneToken = calculateRemoveLiquidityOneToken;
    /**
     * addLiquidity adds a given amount of a user's tokens (such as USDC for Stableswap pools)
     * as liquidity to a Liquidity Pool, providing the user with LP tokens which can be staked.
     *
     * @param {AddLiquidityParams} args {@link AddLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token with which to interact.
     * @param {BigNumber} args.deadline Latest deadline which transaction will be accepted at.
     * @param {Signer} args.signer EthersJS-compatible transaction signer.
     * @param {BigNumber[]} args.amounts Pool-index-relative array of token amounts to add as liquidity to the pool.
     * @param {BigNumber} args.minToMint Amount of LP tokens to mint. Can be calculated with {@link calculateAddLiquidity}.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    function addLiquidity(args) {
        return __awaiter(this, void 0, void 0, function () {
            var err, err, err, swapInstance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isEmpty(args.signer)) {
                            err = new Error("signer must be passed in AddLiquidityParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        else if (_.isEmpty(args.deadline)) {
                            err = new Error("deadline must be passed in AddLiquidityParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        else if (_.isEmpty(args.minToMint)) {
                            err = new Error("minToMint must be passed in AddLiquidityParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        return [4 /*yield*/, swapContractFromLPSwapAddress(args.lpToken.swapAddress, args.chainId, args.signer)];
                    case 1:
                        swapInstance = _a.sent();
                        return [2 /*return*/, swapInstance.addLiquidity(args.amounts, args.minToMint, args.deadline)];
                }
            });
        });
    }
    TokenSwap.addLiquidity = addLiquidity;
    /**
     * removeLiquidity exchanges a given amount of a user's LP tokens for a given Liquidity Pool for
     * various amounts of pooled liquidity tokens, thereby removing liquidity from the Pool.
     *
     * @param {RemoveLiquidityParams} args {@link RemoveLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token with which to interact.
     * @param {BigNumber} args.deadline Latest deadline which transaction will be accepted at.
     * @param {Signer} args.signer EthersJS-compatible transaction signer.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for pooled liquidity tokens.
     * @param {BigNumber[]} args.minAmounts Pool-index-relative array of pooled liquidity token amounts to return in exchange for LP tokens. Can be calculated with {@link calculateRemoveLiquidity}.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    function removeLiquidity(args) {
        return __awaiter(this, void 0, void 0, function () {
            var err, err, err, swapInstance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isEmpty(args.signer)) {
                            err = new Error("signer must be passed in RemoveLiquidityParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        else if (_.isEmpty(args.deadline)) {
                            err = new Error("deadline must be passed in RemoveLiquidityParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        else if (_.isEmpty(args.minAmounts)) {
                            err = new Error("minAmounts must be passed in RemoveLiquidityParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        return [4 /*yield*/, swapContractFromLPSwapAddress(args.lpToken.swapAddress, args.chainId, args.signer)];
                    case 1:
                        swapInstance = _a.sent();
                        return [2 /*return*/, swapInstance.removeLiquidity(args.amount, args.minAmounts, args.deadline)];
                }
            });
        });
    }
    TokenSwap.removeLiquidity = removeLiquidity;
    /**
     * removeLiquidityOneToken exchanges a given amount of a user's LP tokens for a given Liquidity Pool for
     * an amount of a single liquidity token in the given Liquidity Pool, removing that amount from available liquidity
     * and transferring it to the user.
     *
     * @param {RemoveLiquidityOneParams} args {@link RemoveLiquidityOneParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {BigNumber} args.deadline Latest deadline which transaction will be accepted at.
     * @param {Signer} args.signer EthersJS-compatible transaction signer.
     * @param {Token} args.token Token which will be returned to the user in exchange for their LP tokens.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for desired pooled liquidity token.
     * @param {BigNumber} args.minAmount Minimum amount of pooled liquidity token to be removed from the Liquidity Pool and transferred to the user.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    function removeLiquidityOneToken(args) {
        return __awaiter(this, void 0, void 0, function () {
            var err, err, err, swapInstance, tokenAddress, err, tokenIndex, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isEmpty(args.signer)) {
                            err = new Error("signer must be passed in RemoveLiquidityOneParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        else if (_.isEmpty(args.deadline)) {
                            err = new Error("deadline must be passed in RemoveLiquidityOneParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        else if (_.isEmpty(args.minAmount)) {
                            err = new Error("minAmount must be passed in RemoveLiquidityOneParams");
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        return [4 /*yield*/, swapContractFromLPSwapAddress(args.lpToken.swapAddress, args.chainId, args.signer)];
                    case 1:
                        swapInstance = _a.sent();
                        tokenAddress = args.token.address(args.chainId);
                        if (!tokenAddress) {
                            err = new Error("no address for token ".concat(args.token.name, " found for chain id ").concat(args.chainId));
                            return [2 /*return*/, rejectPromise(err)];
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, swapInstance.getTokenIndex(tokenAddress)];
                    case 3:
                        tokenIndex = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _a.sent();
                        return [2 /*return*/, rejectPromise(e_2)];
                    case 5: return [2 /*return*/, swapInstance.removeLiquidityOneToken(args.amount, tokenIndex, args.minAmount, args.deadline)];
                }
            });
        });
    }
    TokenSwap.removeLiquidityOneToken = removeLiquidityOneToken;
    function calculateSwapRate(args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, canSwap, reasonNotSupported;
            return __generator(this, function (_b) {
                _a = swapSupported(args), canSwap = _a.swapSupported, reasonNotSupported = _a.reasonNotSupported;
                if (!canSwap) {
                    return [2 /*return*/, rejectPromise(reasonNotSupported)];
                }
                return [2 /*return*/, resolveSwapData(args)
                        .then(function (_a) {
                        var swapInstance = _a.swapInstance, tokenIndexFrom = _a.tokenIndexFrom, tokenIndexTo = _a.tokenIndexTo;
                        return swapInstance
                            .calculateSwap(tokenIndexFrom, tokenIndexTo, args.amountIn)
                            .then(function (res) { return ({ amountOut: res }); });
                    })
                        .catch(rejectPromise)];
            });
        });
    }
    TokenSwap.calculateSwapRate = calculateSwapRate;
    function swapTokens(args, gasOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, canSwap, reasonNotSupported;
            return __generator(this, function (_b) {
                _a = swapSupported(args), canSwap = _a.swapSupported, reasonNotSupported = _a.reasonNotSupported;
                if (!canSwap) {
                    return [2 /*return*/, rejectPromise(reasonNotSupported)];
                }
                return [2 /*return*/, resolveSwapData(args)
                        .then(function (swapSetup) {
                        var deadline = args.deadline;
                        return swapContract(args.tokenFrom, args.chainId, args.signer)
                            .then(function (swapInstance) {
                            return swapInstance.swap(swapSetup.tokenIndexFrom, swapSetup.tokenIndexTo, args.amountIn, args.minAmountOut, deadline !== null && deadline !== void 0 ? deadline : Math.round((new Date().getTime() / 1000) + 60 * 10), buildSwapTokensOverrides(args, gasOptions));
                        });
                    })
                        .catch(rejectPromise)];
            });
        });
    }
    TokenSwap.swapTokens = swapTokens;
    function buildSwapTokensTransaction(args, gasOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, canSwap, reasonNotSupported;
            return __generator(this, function (_b) {
                _a = swapSupported(args), canSwap = _a.swapSupported, reasonNotSupported = _a.reasonNotSupported;
                if (!canSwap) {
                    return [2 /*return*/, rejectPromise(reasonNotSupported)];
                }
                return [2 /*return*/, resolveSwapData(args)
                        .then(function (swapData) { return populateSwapTransaction(args, swapData, gasOptions); })
                        .catch(rejectPromise)];
            });
        });
    }
    TokenSwap.buildSwapTokensTransaction = buildSwapTokensTransaction;
    function resolveSwapData(args) {
        return __awaiter(this, void 0, void 0, function () {
            var swapData, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        swapData = args.swapData;
                        _b = (_a = Promise).resolve;
                        if (!swapData) return [3 /*break*/, 1];
                        _c = swapData;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, swapSetup(args.tokenFrom, args.tokenTo, args.chainId)];
                    case 2:
                        _c = _d.sent();
                        _d.label = 3;
                    case 3: return [2 /*return*/, _b.apply(_a, [_c])];
                }
            });
        });
    }
    function populateSwapTransaction(args, swapSetup, gasOptions) {
        var _a;
        var deadline = args.deadline;
        var swapInstance = swapSetup.swapInstance;
        var txnProm = swapInstance.populateTransaction.swap(swapSetup.tokenIndexFrom, swapSetup.tokenIndexTo, args.amountIn, args.minAmountOut, deadline !== null && deadline !== void 0 ? deadline : Math.round((new Date().getTime() / 1000) + 60 * 10));
        var gasLimit = (_a = CHAIN_SWAPS_GAS_LIMITS[args.chainId]) === null || _a === void 0 ? void 0 : _a.gasLimit;
        var gasOpts = gasOptions ? gasOptions : {};
        if (gasLimit) {
            gasOpts.gasLimit = gasLimit;
        }
        return txnProm.then(function (txn) { return populateGasOptions(txn, gasOpts, args.chainId); });
    }
    function buildSwapTokensOverrides(args, gasOptions) {
        var chainId = args.chainId;
        var overrides = __assign(__assign({}, makeTransactionGasOverrides(gasOptions, chainId, true)), makeTransactionGasOverrides(CHAIN_SWAPS_GAS_LIMITS[chainId], chainId));
        if (Object.keys(overrides).length === 0) {
            return null;
        }
        return overrides;
    }
    function intermediateTokens(chainId, token, otherChainId) {
        if (mintBurnSwapTypes.includes(token.swapType)) {
            switch (token.swapType) {
                case SwapType.JEWEL:
                    var bridgeConfigIntermediate = chainId === ChainId.HARMONY
                        ? Tokens.SYN_JEWEL
                        : Tokens.JEWEL;
                    return { intermediateToken: Tokens.JEWEL, bridgeConfigIntermediateToken: bridgeConfigIntermediate };
                // case SwapType.AVAX:
                //     break;
                default:
                    return { intermediateToken: token, bridgeConfigIntermediateToken: token };
            }
        }
        var intermediateToken, bridgeConfigIntermediateToken;
        switch (token.swapType) {
            case SwapType.SYN:
                intermediateToken = Tokens.SYN;
                break;
            case SwapType.FRAX:
                bridgeConfigIntermediateToken = chainId === ChainId.ETH ? Tokens.FRAX : Tokens.SYN_FRAX;
                break;
            case SwapType.ETH:
                intermediateToken = Tokens.NETH;
                bridgeConfigIntermediateToken = chainId === ChainId.ETH ? Tokens.WETH : Tokens.NETH;
                break;
            case SwapType.AVAX:
                var fromAvax = chainId === ChainId.AVALANCHE, fromHarmony = chainId === ChainId.HARMONY;
                if (!_.isNil(otherChainId)) {
                    if (fromAvax && otherChainId === ChainId.HARMONY) {
                        intermediateToken = Tokens.WAVAX;
                        bridgeConfigIntermediateToken = Tokens.SYN_AVAX;
                        break;
                    }
                    else if (fromHarmony && otherChainId === ChainId.AVALANCHE) {
                        intermediateToken = Tokens.WAVAX;
                        bridgeConfigIntermediateToken = Tokens.WAVAX;
                        break;
                    }
                    else {
                        intermediateToken = Tokens.WAVAX;
                        bridgeConfigIntermediateToken = chainId === ChainId.HARMONY ? Tokens.SYN_AVAX : Tokens.WAVAX;
                        break;
                    }
                }
                /* c8 ignore next 3 */
                intermediateToken = Tokens.WAVAX;
                bridgeConfigIntermediateToken = chainId === ChainId.HARMONY ? Tokens.SYN_AVAX : Tokens.WAVAX;
                break;
            case SwapType.MOVR:
                intermediateToken = Tokens.WMOVR;
                break;
            default:
                intermediateToken = Tokens.NUSD;
                break;
        }
        bridgeConfigIntermediateToken = bridgeConfigIntermediateToken !== null && bridgeConfigIntermediateToken !== void 0 ? bridgeConfigIntermediateToken : intermediateToken;
        return { intermediateToken: intermediateToken, bridgeConfigIntermediateToken: bridgeConfigIntermediateToken };
    }
    TokenSwap.intermediateTokens = intermediateTokens;
    function detailedTokenSwapMap() {
        var res = {};
        var allChainIds = supportedChainIds();
        var _loop_1 = function (c1) {
            var n1 = Networks.fromChainId(c1);
            var networkTokens = n1.tokens;
            var chainGasToken = Tokens.gasTokenForChain(c1);
            res[c1] = networkTokens.map(function (t) {
                var swapType = t.swapType;
                if (!_.isNull(chainGasToken)) {
                    var gasWrapper = Tokens.gasTokenWrapper(chainGasToken);
                    if (gasWrapper.isEqual(t)) {
                        return;
                    }
                }
                var tokSwapMap = {
                    token: t,
                };
                var _loop_2 = function (c2) {
                    if (c1 === c2)
                        return "continue";
                    if (c1 === ChainId.AVALANCHE && t.isEqual(Tokens.MULTIJEWEL) && c2 !== ChainId.DFK) {
                        return "continue";
                    }
                    var chain2GasToken = Tokens.gasTokenForChain(c2);
                    var outToks = SwapPools.tokensForChainBySwapGroup(c2, swapType);
                    if (outToks.length === 0)
                        return "continue";
                    outToks = outToks.filter(function (t2) {
                        if (!_.isNull(chain2GasToken)) {
                            return !Tokens.gasTokenWrapper(chain2GasToken).isEqual(t2);
                        }
                        return true;
                    });
                    tokSwapMap[c2] = outToks;
                };
                for (var _i = 0, allChainIds_2 = allChainIds; _i < allChainIds_2.length; _i++) {
                    var c2 = allChainIds_2[_i];
                    _loop_2(c2);
                }
                return tokSwapMap;
            }).filter(function (t) { return !_.isUndefined(t); });
        };
        for (var _i = 0, allChainIds_1 = allChainIds; _i < allChainIds_1.length; _i++) {
            var c1 = allChainIds_1[_i];
            _loop_1(c1);
        }
        return res;
    }
    TokenSwap.detailedTokenSwapMap = detailedTokenSwapMap;
    function swapContract(token, chainId, signer) {
        return __awaiter(this, void 0, void 0, function () {
            var provider, lpToken;
            return __generator(this, function (_a) {
                provider = signer ? signer : rpcProviderForChain(chainId);
                lpToken = _intermediateToken(token, chainId);
                // temp fix until BridgeConfig is updated
                if (lpToken.isEqual(Tokens.NUSD) && chainId === ChainId.CRONOS) {
                    return [2 /*return*/, swapContractFromLPSwapAddress(SwapPools.stableswapPoolForNetwork(chainId).swapAddress, chainId, signer)];
                }
                return [2 /*return*/, BRIDGE_CONFIG_INSTANCE.getPoolConfig(lpToken.address(chainId), chainId)
                        .then(function (_a) {
                        var poolAddress = _a.poolAddress;
                        return SwapFactory.connect(poolAddress, provider);
                    })
                        .catch(rejectPromise)];
            });
        });
    }
    TokenSwap.swapContract = swapContract;
    function swapContractFromLPSwapAddress(lpSwapAddress, chainId, signer) {
        return __awaiter(this, void 0, void 0, function () {
            var provider;
            return __generator(this, function (_a) {
                provider = signer ? signer : rpcProviderForChain(chainId);
                return [2 /*return*/, SwapFactory.connect(lpSwapAddress, provider)];
            });
        });
    }
    function swapSetup(tokenFrom, tokenTo, chainId) {
        return __awaiter(this, void 0, void 0, function () {
            var swapInstance;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, swapContract(tokenFrom, chainId)];
                    case 1:
                        swapInstance = _a.sent();
                        return [2 /*return*/, Promise.all([
                                swapInstance.getTokenIndex(tokenFrom.address(chainId)),
                                swapInstance.getTokenIndex(tokenTo.address(chainId)),
                            ]).then(function (_a) {
                                var tokenIndexFrom = _a[0], tokenIndexTo = _a[1];
                                return ({
                                    swapInstance: swapInstance,
                                    tokenIndexFrom: tokenIndexFrom,
                                    tokenIndexTo: tokenIndexTo,
                                });
                            }).catch(rejectPromise)];
                }
            });
        });
    }
    TokenSwap.swapSetup = swapSetup;
    function _intermediateToken(token, chainId) {
        var _a = intermediateTokens(chainId, token), intermediateToken = _a.intermediateToken, bridgeConfigIntermediateToken = _a.bridgeConfigIntermediateToken;
        /* c8 ignore next */
        return intermediateToken !== null && intermediateToken !== void 0 ? intermediateToken : bridgeConfigIntermediateToken;
    }
    function checkCanSwap(tokenFrom, tokenTo, chainFrom, chainTo) {
        var tokensCanSwap = checkTokensCanSwap(tokenFrom, tokenTo), tokensSupported = checkTokensSupported(tokenFrom, tokenTo, chainFrom, chainTo);
        if (!tokensSupported.swapSupported) {
            return tokensSupported;
        }
        else if (!tokensCanSwap.swapSupported) {
            return tokensCanSwap;
        }
        return { swapSupported: true };
    }
    function checkTokensCanSwap(tokenFrom, tokenTo) {
        var swapSupported = true, reasonNotSupported;
        if (tokenFrom.swapType !== tokenTo.swapType) {
            swapSupported = false;
            reasonNotSupported = UnsupportedSwapErrors.nonMatchingSwapTypes();
        }
        return { swapSupported: swapSupported, reasonNotSupported: reasonNotSupported };
    }
    function checkTokensSupported(tokenFrom, tokenTo, chainIdFrom, chainIdTo) {
        var hasDestChain = !_.isUndefined(chainIdTo);
        var unsupportedFromErr = hasDestChain ? UnsupportedSwapErrors.tokenNotSupportedNetFrom : UnsupportedSwapErrors.tokenNotSupported, unsupportedToErr = hasDestChain ? UnsupportedSwapErrors.tokenNotSupportedNetTo : UnsupportedSwapErrors.tokenNotSupported;
        var netFrom = Networks.fromChainId(chainIdFrom), netTo = hasDestChain ? Networks.fromChainId(chainIdTo) : netFrom;
        if (hasDestChain) {
            if (tokenFrom.isEqual(Tokens.MULTIJEWEL) && chainIdTo !== ChainId.DFK) {
                return { swapSupported: false, reasonNotSupported: UnsupportedSwapErrors.unsupportedMultiJEWELMigration() };
            }
        }
        var swapSupported = true, reasonNotSupported;
        if (!netFrom.supportsToken(tokenFrom)) {
            swapSupported = false;
            reasonNotSupported = unsupportedFromErr(tokenFrom, netFrom.name);
        }
        else if (!netTo.supportsToken(tokenTo)) {
            swapSupported = false;
            reasonNotSupported = unsupportedToErr(tokenTo, netTo.name);
        }
        return { swapSupported: swapSupported, reasonNotSupported: reasonNotSupported };
    }
})(TokenSwap || (TokenSwap = {}));
