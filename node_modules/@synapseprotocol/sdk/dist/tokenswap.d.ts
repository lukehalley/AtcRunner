import type { Token } from "./token";
import { SwapPools } from "./swappools";
import { SwapContract } from "./contracts";
import { BigNumber, type BigNumberish } from "@ethersproject/bignumber";
import type { Signer } from "@ethersproject/abstract-signer";
import { type ContractTransaction, type PopulatedTransaction } from "@ethersproject/contracts";
import { GasOptions } from "./common/gasoptions";
export declare namespace UnsupportedSwapErrors {
    enum UnsupportedSwapErrorKind {
        UnsupportedToken = 0,
        UnsupportedTokenNetFrom = 1,
        UnsupportedTokenNetTo = 2,
        NonmatchingSwapTypes = 3,
        UnsupportedMultiJEWELMigration = 4
    }
    interface UnsupportedSwapErrorArgs {
        reason: string;
        errorKind: UnsupportedSwapErrorKind;
    }
    class UnsupportedSwapError extends Error {
        readonly reason: string;
        readonly errorKind: UnsupportedSwapErrorKind;
        constructor({ reason, errorKind }: UnsupportedSwapErrorArgs);
    }
    const tokenNotSupported: (t: {
        symbol: string;
    }, netName: string) => UnsupportedSwapError;
    const tokenNotSupportedNetFrom: (t: {
        symbol: string;
    }, netName: string) => UnsupportedSwapError;
    const tokenNotSupportedNetTo: (t: {
        symbol: string;
    }, netName: string) => UnsupportedSwapError;
    const nonMatchingSwapTypes: () => UnsupportedSwapError;
    const unsupportedMultiJEWELMigration: () => UnsupportedSwapError;
}
export declare namespace TokenSwap {
    export interface SwapParams {
        chainId: number;
        tokenFrom: Token;
        tokenTo: Token;
        amountIn: BigNumberish;
        swapData?: SwapSetup;
    }
    export interface SwapTokensParams extends SwapParams {
        minAmountOut: BigNumberish;
        deadline?: number;
    }
    export interface BridgeSwapSupportedParams {
        tokenFrom: Token;
        tokenTo: Token;
        chainIdFrom: number;
        chainIdTo: number;
    }
    export interface AddRemoveLiquidityParams {
        chainId: number;
        lpToken: SwapPools.SwapPoolToken;
        deadline?: BigNumber;
        signer?: Signer;
    }
    export interface AddLiquidityParams extends AddRemoveLiquidityParams {
        amounts: BigNumber[];
        minToMint?: BigNumber;
    }
    export interface RemoveLiquidityParams extends AddRemoveLiquidityParams {
        amount: BigNumber;
        minAmounts?: BigNumber[];
    }
    export interface RemoveLiquidityOneParams extends AddRemoveLiquidityParams {
        token: Token;
        amount: BigNumber;
        minAmount?: BigNumber;
    }
    export type EstimatedSwapRate = {
        amountOut: BigNumber;
    };
    export type IntermediateSwapTokens = {
        intermediateToken?: Token;
        bridgeConfigIntermediateToken: Token;
    };
    export type SwapSupportedResult = {
        swapSupported: boolean;
        reasonNotSupported?: UnsupportedSwapErrors.UnsupportedSwapError;
    };
    export type DetailedTokenSwapMap = {
        [chainId: number]: {
            token: Token;
            [chainId: number]: Token[];
        }[];
    };
    export function swapSupported(args: SwapParams): SwapSupportedResult;
    export function bridgeSwapSupported(args: BridgeSwapSupportedParams): SwapSupportedResult;
    /**
     * calculateAddLiquidity returns the estimated number of LP tokens which a user would receive
     * were they to deposit a given number of liquidity tokens into a pool.
     *
     * @param {AddLiquidityParams} args {@link AddLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {BigNumber[]} args.amounts Pool-index-relative array of token amounts to add as liquidity to the pool.
     *
     * @return {BigNumber} Amount of LP tokens a user would receive if the deposited liquidity tokens into the pool.
     */
    export function calculateAddLiquidity(args: AddLiquidityParams): Promise<BigNumber>;
    /**
     * calculateRemoveLiquidity returns the estimated number of pooled tokens which a user would receive
     * were they to return some amount of their LP tokens to the Pool.
     *
     * @param {RemoveLiquidityParams} args {@link RemoveLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for pooled liquidity tokens.
     *
     * @return {BigNumber[]} Pool-index-relative array of token amounts which a user would receive if they remove the passed amount of LP tokens.
     */
    export function calculateRemoveLiquidity(args: RemoveLiquidityParams): Promise<BigNumber[]>;
    /**
     * calculateRemoveLiquidityOneToken returns the estimated number of a single pooled token
     * which would be removed from a Liquidity Pool and transferred to a user
     * were they to return some amount of their LP tokens to the Pool.
     *
     * @param {RemoveLiquidityOneParams} args {@link RemoveLiquidityOneParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {Token} args.token Token which will be removed as liquidity from the Liquidity Pool and transferred to the user in exchange for their LP tokens.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for desired pooled liquidity token.
     *
     * @return {BigNumber} Amount of a single pooled liquidity token which would be removed from the Liquidity Pool and transferred to the user.
     */
    export function calculateRemoveLiquidityOneToken(args: RemoveLiquidityOneParams): Promise<BigNumber>;
    /**
     * addLiquidity adds a given amount of a user's tokens (such as USDC for Stableswap pools)
     * as liquidity to a Liquidity Pool, providing the user with LP tokens which can be staked.
     *
     * @param {AddLiquidityParams} args {@link AddLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token with which to interact.
     * @param {BigNumber} args.deadline Latest deadline which transaction will be accepted at.
     * @param {Signer} args.signer EthersJS-compatible transaction signer.
     * @param {BigNumber[]} args.amounts Pool-index-relative array of token amounts to add as liquidity to the pool.
     * @param {BigNumber} args.minToMint Amount of LP tokens to mint. Can be calculated with {@link calculateAddLiquidity}.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    export function addLiquidity(args: AddLiquidityParams): Promise<ContractTransaction>;
    /**
     * removeLiquidity exchanges a given amount of a user's LP tokens for a given Liquidity Pool for
     * various amounts of pooled liquidity tokens, thereby removing liquidity from the Pool.
     *
     * @param {RemoveLiquidityParams} args {@link RemoveLiquidityParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token with which to interact.
     * @param {BigNumber} args.deadline Latest deadline which transaction will be accepted at.
     * @param {Signer} args.signer EthersJS-compatible transaction signer.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for pooled liquidity tokens.
     * @param {BigNumber[]} args.minAmounts Pool-index-relative array of pooled liquidity token amounts to return in exchange for LP tokens. Can be calculated with {@link calculateRemoveLiquidity}.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    export function removeLiquidity(args: RemoveLiquidityParams): Promise<ContractTransaction>;
    /**
     * removeLiquidityOneToken exchanges a given amount of a user's LP tokens for a given Liquidity Pool for
     * an amount of a single liquidity token in the given Liquidity Pool, removing that amount from available liquidity
     * and transferring it to the user.
     *
     * @param {RemoveLiquidityOneParams} args {@link RemoveLiquidityOneParams} object containing arguments.
     * @param {number} args.chainId Chain ID of the Liquidity Pool.
     * @param {SwapPools.SwapPoolToken} args.lpToken LP Token/Pool with which to interact.
     * @param {BigNumber} args.deadline Latest deadline which transaction will be accepted at.
     * @param {Signer} args.signer EthersJS-compatible transaction signer.
     * @param {Token} args.token Token which will be returned to the user in exchange for their LP tokens.
     * @param {BigNumber} args.amount Amount of LP tokens to exchange for desired pooled liquidity token.
     * @param {BigNumber} args.minAmount Minimum amount of pooled liquidity token to be removed from the Liquidity Pool and transferred to the user.
     *
     * @return {Promise<ContractTransaction>} Executed transaction object.
     */
    export function removeLiquidityOneToken(args: RemoveLiquidityOneParams): Promise<ContractTransaction>;
    export function calculateSwapRate(args: SwapParams): Promise<EstimatedSwapRate>;
    interface SwapTokensFnParams extends SwapTokensParams {
        signer: Signer;
    }
    export function swapTokens(args: SwapTokensFnParams, gasOptions?: GasOptions): Promise<ContractTransaction>;
    export function buildSwapTokensTransaction(args: SwapTokensParams, gasOptions?: GasOptions): Promise<PopulatedTransaction>;
    export function intermediateTokens(chainId: number, token: Token, otherChainId?: number): IntermediateSwapTokens;
    export function detailedTokenSwapMap(): DetailedTokenSwapMap;
    interface SwapSetup {
        swapInstance: SwapContract;
        tokenIndexFrom: number;
        tokenIndexTo: number;
    }
    export function swapContract(token: Token, chainId: number, signer?: Signer): Promise<SwapContract>;
    export function swapSetup(tokenFrom: Token, tokenTo: Token, chainId: number): Promise<SwapSetup>;
    export {};
}
