import { Slippages } from "./slippages.js";
import { Tokens } from "../tokens.js";
import { ChainId } from "../common/chainid.js";
import { SwapPools } from "../swappools.js";
import * as SynapseEntities from "../entities.js";
import { tokenSwitch } from "../internal/utils.js";
import { rpcProviderForChain } from "../internal/rpcproviders.js";
import { Zero } from "@ethersproject/constants";
export var BridgeUtils;
(function (BridgeUtils) {
    BridgeUtils.L2_ETH_CHAINS = [
        ChainId.OPTIMISM,
        ChainId.FANTOM,
        ChainId.BOBA,
        ChainId.METIS,
        ChainId.MOONBEAM,
        ChainId.ARBITRUM,
        ChainId.AVALANCHE,
        ChainId.HARMONY,
    ];
    BridgeUtils.GAS_TOKEN_CHAINS = [
        ChainId.ETH,
        ChainId.OPTIMISM,
        ChainId.BOBA,
        ChainId.ARBITRUM,
        ChainId.AVALANCHE,
        ChainId.DFK
    ];
    BridgeUtils.isL2ETHChain = function (chainId) { return BridgeUtils.L2_ETH_CHAINS.includes(chainId); };
    BridgeUtils.chainSupportsGasToken = function (chainId) { return BridgeUtils.GAS_TOKEN_CHAINS.includes(chainId); };
    BridgeUtils.DepositIfChainTokens = [
        { chainId: ChainId.FANTOM, tokens: [Tokens.JUMP], redeemChainIds: [ChainId.BSC], depositEth: false },
        { chainId: ChainId.POLYGON, tokens: [Tokens.NFD], redeemChainIds: [], depositEth: false },
        { chainId: ChainId.MOONRIVER, tokens: [Tokens.SOLAR], redeemChainIds: [], depositEth: false },
        {
            chainId: ChainId.AVALANCHE,
            tokens: [Tokens.AVAX, Tokens.WAVAX, Tokens.SYN_AVAX],
            redeemChainIds: [ChainId.MOONBEAM, ChainId.DFK],
            depositEth: true
        },
        { chainId: ChainId.MOONRIVER, tokens: [Tokens.MOVR, Tokens.WMOVR], redeemChainIds: [ChainId.MOONBEAM], depositEth: true },
        {
            chainId: ChainId.HARMONY,
            tokens: [Tokens.XJEWEL],
            redeemChainIds: [ChainId.DFK],
            depositEth: false,
        },
        { chainId: ChainId.ARBITRUM, tokens: [Tokens.VSTA], redeemChainIds: [], depositEth: false },
    ];
    function getBridgeTxArgs() {
        return {
            slippageCustom: null,
            slippageSelected: Slippages.OneTenth,
            infiniteApproval: true,
            transactionDeadline: BridgeUtils.getTimeMinutesFromNow(10),
            bridgeTransactionDeadline: BridgeUtils.getTimeMinutesFromNow(60 * 24)
        };
    }
    BridgeUtils.getBridgeTxArgs = getBridgeTxArgs;
    function getSlippages(amountFrom, amountTo) {
        var _a = getBridgeTxArgs(), slippageSelected = _a.slippageSelected, transactionDeadline = _a.transactionDeadline, bridgeTransactionDeadline = _a.bridgeTransactionDeadline;
        var selectedGasArgs = slippageSelected, twoTenthGasArgs = Slippages.TwoTenth, quarterGasArgs = Slippages.Quarter;
        var minToSwapOrigin = Slippages.subtractSlippage(amountFrom, selectedGasArgs), minToSwapDest = Slippages.subtractSlippage(amountTo, selectedGasArgs), minToSwapDestFromOrigin = Slippages.subtractSlippage(minToSwapDest, selectedGasArgs);
        var minToSwapOriginMediumSlippage = Slippages.subtractSlippage(amountFrom, twoTenthGasArgs), minToSwapDestMediumSlippage = Slippages.subtractSlippage(amountTo, twoTenthGasArgs), minToSwapDestFromOriginMediumSlippage = Slippages.subtractSlippage(minToSwapDestMediumSlippage, twoTenthGasArgs);
        var minToSwapOriginHighSlippage = Slippages.subtractSlippage(amountFrom, quarterGasArgs), minToSwapDestHighSlippage = Slippages.subtractSlippage(amountTo, quarterGasArgs), minToSwapDestFromOriginHighSlippage = Slippages.subtractSlippage(minToSwapDestHighSlippage, quarterGasArgs);
        return {
            slippageSelected: slippageSelected,
            transactionDeadline: transactionDeadline,
            bridgeTransactionDeadline: bridgeTransactionDeadline,
            minToSwapOrigin: minToSwapOrigin,
            minToSwapDest: minToSwapDest,
            minToSwapDestFromOrigin: minToSwapDestFromOrigin,
            minToSwapOriginMediumSlippage: minToSwapOriginMediumSlippage,
            minToSwapDestMediumSlippage: minToSwapDestMediumSlippage,
            minToSwapDestFromOriginMediumSlippage: minToSwapDestFromOriginMediumSlippage,
            minToSwapOriginHighSlippage: minToSwapOriginHighSlippage,
            minToSwapDestHighSlippage: minToSwapDestHighSlippage,
            minToSwapDestFromOriginHighSlippage: minToSwapDestFromOriginHighSlippage,
        };
    }
    BridgeUtils.getSlippages = getSlippages;
    BridgeUtils.entityParams = function (chainId) { return ({ chainId: chainId, signerOrProvider: rpcProviderForChain(chainId) }); };
    BridgeUtils.newL1BridgeZap = function (chainId) { return SynapseEntities.L1BridgeZapContractInstance(BridgeUtils.entityParams(chainId)); }, BridgeUtils.newL2BridgeZap = function (chainId) { return SynapseEntities.L2BridgeZapContractInstance(BridgeUtils.entityParams(chainId)); }, BridgeUtils.newBridgeZap = function (chainId) { return SynapseEntities.GenericZapBridgeContractInstance(BridgeUtils.entityParams(chainId)); };
    BridgeUtils.subBigNumSafe = function (a, b) { return a.gt(b) ? a.sub(b) : Zero; };
    BridgeUtils.getTimeMinutesFromNow = function (minutesFromNow) {
        return Math.round((new Date().getTime() / 1000) + 60 * minutesFromNow);
    };
    BridgeUtils.makeEasyParams = function (args, chainId, t) {
        return [args.addressTo, args.chainIdTo, t.address(chainId), args.amountFrom];
    };
    BridgeUtils.makeEasySubParams = function (args, chainId, t) {
        var x = BridgeUtils.makeEasyParams(args, chainId, t);
        return [x[0], x[1], x[2]];
    };
    BridgeUtils.depositETHParams = function (args) {
        return [args.addressTo, args.chainIdTo, args.amountFrom];
    };
    BridgeUtils.isETHLikeToken = function (t) {
        return [Tokens.WETH_E.id, Tokens.ONE_ETH.id, Tokens.FTM_ETH.id, Tokens.METIS_ETH.id].includes(t.id);
    };
    BridgeUtils.overrides = function (value) { return ({ value: value }); };
    /**
     * Switch t1 with t3 is t1 is t2
     * @param {Token} t1 token being checked
     * @param {Token} t2 token to check t1 against
     * @param {Token} t3 token to return instead of t1 if t1 equals t2
     */
    var checkReplaceToken = function (t1, t2, t3) { return t1.isEqual(t2) ? t3 : t1; };
    BridgeUtils.checkReplaceTokens = function (check, replace) {
        return function (t1, t2) { return [
            checkReplaceToken(t1, check, replace),
            checkReplaceToken(t2, check, replace)
        ]; };
    };
    function findSymbol(t1, t2, chainId) {
        var compare = t2;
        switch (tokenSwitch(t2)) {
            case Tokens.WETH_E:
                compare = Tokens.AVWETH;
                break;
            case Tokens.WETH:
                compare = Tokens.WETH;
                break;
            case Tokens.JEWEL:
                if (chainId === ChainId.HARMONY) {
                    compare = Tokens.SYN_JEWEL;
                }
                else {
                    compare = t2.underlyingToken;
                }
                break;
            case Tokens.WAVAX:
                if (chainId !== ChainId.DFK) {
                    compare = t2.underlyingToken;
                }
                break;
            default:
                if (t2.isWrapperToken && t2.underlyingToken) {
                    compare = t2.underlyingToken;
                }
                break;
        }
        return t1.isEqual(compare);
    }
    function makeTokenArgs(chainId, t) {
        var toks = SwapPools.bridgeSwappableMap[chainId].swappableSwapGroups[t.swapType].poolTokens, idx = toks.findIndex(function (tok) { return findSymbol(tok, t, chainId); });
        return [toks, idx];
    }
    BridgeUtils.makeTokenArgs = makeTokenArgs;
})(BridgeUtils || (BridgeUtils = {}));
