import { Networks } from "../common/networks";
import { type Token } from "../token";
import { TokenSwap } from "../tokenswap";
import { type GasOptions } from "../common/gasoptions";
import { ERC20 } from "./erc20";
import { BigNumber } from "@ethersproject/bignumber";
import type { BigNumberish } from "@ethersproject/bignumber";
import type { Signer } from "@ethersproject/abstract-signer";
import type { Provider } from "@ethersproject/providers";
import type { ContractTransaction, PopulatedTransaction } from "@ethersproject/contracts";
/**
 * Bridge provides a wrapper around common Synapse Bridge interactions, such as output estimation, checking supported swaps/bridges,
 * and most importantly, executing Bridge transactions.
 */
export declare namespace Bridge {
    export type CanBridgeResult = {
        canBridge: boolean;
        reasonUnable?: string;
        amount?: BigNumber;
    };
    export type BridgeOutputEstimate = {
        amountToReceive: BigNumber;
        bridgeFee: BigNumber;
    };
    /**
     * @param {Token} tokenFrom {@link Token} user will send to the bridge on the source chain
     * @param {Token} tokenTo {@link Token} user will receive from the bridge on the destination chain
     * @param {number} chainIdTo Chain ID of the destination chain
     * @param {BigNumber} amountFrom not necessarily used by this interface, and overriden in BridgeParamsWithAmounts.
     */
    export interface BridgeParams {
        tokenFrom: Token;
        tokenTo: Token;
        chainIdTo: number;
        amountFrom?: BigNumber;
    }
    /**
     * @param {BigNumber} amountFrom Amount of tokenFrom (denoted in wei) that the user will send to the bridge on the source chain.
     * @param {BigNumber} amountTo Amount of tokenTo (denoted in wei) that the user will receive from the bridge on the destination chain.
     * @param {string} addressTo Optional, user can provide an address other than the one retrieved from signer to receive tokens
     * on the destination chain.
     */
    export interface BridgeTransactionParams extends BridgeParams {
        amountFrom: BigNumber;
        amountTo: BigNumber;
        addressTo?: string;
    }
    interface CheckCanBridgeParams {
        address?: string;
        signer?: Signer;
        token: Token;
        amount: BigNumberish;
    }
    /**
     * SynapseBridge is a wrapper around any Synapse Bridge contract which exists on chains supported by the Synapse Protocol.
     */
    export class SynapseBridge {
        readonly chainId: number;
        protected network: Networks.Network;
        protected provider: Provider;
        private readonly bridgeAddress;
        private readonly zapBridgeAddress;
        private readonly bridgeInstance;
        private readonly zapBridge;
        private readonly l1BridgeZapEth;
        private readonly bridgeConfig;
        private readonly isL2ETHChain;
        readonly requiredConfirmations: number;
        constructor(args: {
            network: Networks.Network | number;
            provider?: Provider;
        });
        private get l2BridgeZap();
        bridgeVersion(): Promise<BigNumber>;
        WETH_ADDRESS(): Promise<string>;
        kappaExists(kappa: string): Promise<boolean>;
        /**
         * Returns whether a swap/bridge from this Bridge's chain to another chain between two tokens
         * is supported.
         * @param {Token} args.tokenFrom {@link Token} user will send to the bridge
         * @param {Token} args.tokenTo {@link Token} user will receive from the bridge on the destination chain
         * @param {number} args.chainIdTo Chain ID of the destination chain
         * @return boolean value denoting whether the input params constitute a valid swap/bridge, along with a
         * string value denoting the reason for an unsupported swap, if applicable.
         */
        swapSupported(args: {
            tokenFrom: Token;
            tokenTo: Token;
            chainIdTo: number;
        }): [boolean, string];
        /**
         * Returns the estimated output of a given token on the destination chain were a user to send
         * some amount of another given token on the source chain.
         * @param {BridgeParams} args Parameters for the output estimation.
         * @return {Promise<BridgeOutputEstimate>} Object containing the estimated output of args.tokenTo, as well
         * as the estimated fee to be taken by the bridge. Note that the estimated output already accounts for the
         * bridge fee, so the bridge fee is entirely for user-facing purposes. Do not use it for calculations.
         */
        estimateBridgeTokenOutput(args: BridgeParams): Promise<BridgeOutputEstimate>;
        /**
         * Returns a populated transaction for initiating a token bridge between this Bridge (the source chain) and the bridge contract on the destination chain.
         * Note that this function **does not** send a signed transaction.
         * @param {BridgeTransactionParams} args Parameters for the bridge transaction
         * @param {GasOptions} gasOptions Optional gas price/fee options for the populated transaction.
         * @return {Promise<PopulatedTransaction>} Populated transaction instance which can be sent via ones choice
         * of web3/ethers/etc.
         */
        buildBridgeTokenTransaction(args: BridgeTransactionParams, gasOptions?: GasOptions): Promise<PopulatedTransaction>;
        /**
         * Starts the Bridge process between this Bridge (the source chain) and the bridge contract on the destination chain.
         * Note that this function **does** send a signed transaction.
         * @param {BridgeTransactionParams} args Parameters for the bridge transaction.
         * @param {Signer} signer Some instance which implements the Ethersjs {@link Signer} interface.
         * @param {boolean} callStatic (Optional, default: false) if true, uses provider.callStatic instead of actually sending the signed transaction.
         * @return {Promise<ContractTransaction>}
         */
        executeBridgeTokenTransaction(args: BridgeTransactionParams, signer: Signer, callStatic?: boolean): Promise<ContractTransaction>;
        /**
         * Builds an ethers PopulatedTransaction instance for an ERC20 Approve call,
         * approving some amount of a given token to be spent by the Synapse Bridge on its chain.
         * The returned PopulatedTransaction must then be passed to the user via Web3 or some other
         * framework so they can ultimately send the transaction.
         * Should ALWAYS be called before performing any bridge transactions to ensure they don't fail.
         * @param {Object} args
         * @param {Token|string} args.token {@link Token} instance or valid on-chain address of the token the user will be sending
         * to the bridge on the source chain.
         * @param {BigNumberish} args.amount Optional, a specific amount of args.token to approve. By default, this function
         * builds an Approve call using an "infinite" approval amount.
         * @param {GasOptions} gasOptions Optional gas price/fee options for the populated transaction.
         * @return {Promise<PopulatedTransaction>} Populated transaction instance which can be sent via ones choice
         * of web3/ethers/etc.
         */
        buildApproveTransaction(args: {
            token: Token | string;
            amount?: BigNumberish;
        }, gasOptions?: GasOptions): Promise<PopulatedTransaction>;
        /**
         * Builds and executes an ERC20 Approve call,
         * approving some amount of a given token to be spent by the Synapse Bridge on its chain.
         * The returned PopulatedTransaction must then be passed to the user via Web3 or some other
         * framework so they can ultimately send the transaction.
         * Should ALWAYS be called before performing any bridge transactions to ensure they don't fail.
         * @param {Object} args
         * @param {Token|string} args.token {@link Token} instance or valid on-chain address of the token the user will be sending
         * to the bridge on the source chain.
         * @param {BigNumberish} args.amount Optional, a specific amount of args.token to approve. By default, this function
         * @param {Signer} signer Valid ethers Signer instance for building a fully and properly populated
         * transaction.
         */
        executeApproveTransaction(args: {
            token: Token | string;
            amount?: BigNumberish;
        }, signer: Signer): Promise<ContractTransaction>;
        getAllowanceForAddress(args: {
            address: string;
            token: Token;
        }): Promise<BigNumber>;
        private resolveApproveFunc;
        private checkNeedsApprove;
        private resolveBalanceFunc;
        private checkGasTokenBalance;
        checkCanBridge(args: CheckCanBridgeParams): Promise<CanBridgeResult>;
        private checkERC20Balance;
        buildERC20ApproveArgs(args: {
            token: Token | string;
            amount?: BigNumberish;
        }): [ERC20.ApproveArgs, string];
        private checkSwapSupported;
        private calculateBridgeRate;
        private checkEasyArgs;
        private buildETHMainnetBridgeTxn;
        private buildL2BridgeTxn;
        private makeBridgeTokenArgs;
    }
    export function getRequiredConfirmationsForBridge(network: Networks.Network | number): number | null;
    export function bridgeSwapSupported(args: TokenSwap.BridgeSwapSupportedParams): TokenSwap.SwapSupportedResult;
    export interface BridgeTransactionCompleteParams {
        chainIdTo: number;
        transactionHashChainFrom: string;
    }
    export function checkBridgeTransactionComplete(args: BridgeTransactionCompleteParams): Promise<boolean>;
    export {};
}
