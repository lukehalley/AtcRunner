var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { ChainId } from "../common/chainid.js";
import { Networks } from "../common/networks.js";
import { instanceOfToken } from "../token.js";
import { Tokens } from "../tokens.js";
import { TokenSwap } from "../tokenswap.js";
import { rejectPromise, executePopulatedTransaction } from "../common/utils.js";
import { populateGasOptions } from "../common/gasoptions.js";
import { SynapseContracts } from "../common/synapse_contracts.js";
import { SwapType } from "../internal/swaptype.js";
import { rpcProviderForChain } from "../internal/rpcproviders.js";
import { tokenSwitch } from "../internal/utils.js";
import * as SynapseEntities from "../entities.js";
import { BridgeConfig } from "./bridgeconfig.js";
import { GasUtils } from "./gasutils.js";
import { BridgeUtils } from "./bridgeutils.js";
import { ERC20, MAX_APPROVAL_AMOUNT } from "./erc20.js";
import { id as makeKappa } from "@ethersproject/hash";
import { Zero } from "@ethersproject/constants";
import { formatUnits } from "@ethersproject/units";
/**
 * Bridge provides a wrapper around common Synapse Bridge interactions, such as output estimation, checking supported swaps/bridges,
 * and most importantly, executing Bridge transactions.
 */
export var Bridge;
(function (Bridge) {
    var _a;
    /**
     * SynapseBridge is a wrapper around any Synapse Bridge contract which exists on chains supported by the Synapse Protocol.
     */
    var SynapseBridge = /** @class */ (function () {
        function SynapseBridge(args) {
            this.l1BridgeZapEth = BridgeUtils.newL1BridgeZap(ChainId.ETH);
            this.bridgeConfig = new BridgeConfig();
            var network = args.network, provider = args.provider;
            this.network = network instanceof Networks.Network ? network : Networks.fromChainId(network);
            this.chainId = this.network.chainId;
            this.provider = provider !== null && provider !== void 0 ? provider : rpcProviderForChain(this.chainId);
            this.requiredConfirmations = getRequiredConfirmationsForBridge(this.network);
            this.isL2ETHChain = BridgeUtils.isL2ETHChain(this.chainId);
            var contractAddrs = SynapseContracts.contractsForChainId(this.chainId);
            this.bridgeAddress = contractAddrs.bridgeAddress;
            this.zapBridgeAddress = contractAddrs.bridgeZapAddress;
            this.bridgeInstance = SynapseEntities.SynapseBridgeContractInstance(BridgeUtils.entityParams(this.chainId));
            if (this.zapBridgeAddress && this.zapBridgeAddress !== "") {
                this.zapBridge = BridgeUtils.newBridgeZap(this.chainId);
            }
        }
        Object.defineProperty(SynapseBridge.prototype, "l2BridgeZap", {
            get: function () {
                return this.zapBridge;
            },
            enumerable: false,
            configurable: true
        });
        SynapseBridge.prototype.bridgeVersion = function () {
            return this.bridgeInstance.bridgeVersion();
        };
        SynapseBridge.prototype.WETH_ADDRESS = function () {
            return this.bridgeInstance.WETH_ADDRESS();
        };
        SynapseBridge.prototype.kappaExists = function (kappa) {
            return this.bridgeInstance.kappaExists(kappa);
        };
        /**
         * Returns whether a swap/bridge from this Bridge's chain to another chain between two tokens
         * is supported.
         * @param {Token} args.tokenFrom {@link Token} user will send to the bridge
         * @param {Token} args.tokenTo {@link Token} user will receive from the bridge on the destination chain
         * @param {number} args.chainIdTo Chain ID of the destination chain
         * @return boolean value denoting whether the input params constitute a valid swap/bridge, along with a
         * string value denoting the reason for an unsupported swap, if applicable.
         */
        SynapseBridge.prototype.swapSupported = function (args) {
            var _a = bridgeSwapSupported(__assign(__assign({}, args), { chainIdFrom: this.chainId })), swapSupported = _a.swapSupported, reasonNotSupported = _a.reasonNotSupported;
            return [swapSupported, (reasonNotSupported === null || reasonNotSupported === void 0 ? void 0 : reasonNotSupported.reason) || ""];
        };
        /**
         * Returns the estimated output of a given token on the destination chain were a user to send
         * some amount of another given token on the source chain.
         * @param {BridgeParams} args Parameters for the output estimation.
         * @return {Promise<BridgeOutputEstimate>} Object containing the estimated output of args.tokenTo, as well
         * as the estimated fee to be taken by the bridge. Note that the estimated output already accounts for the
         * bridge fee, so the bridge fee is entirely for user-facing purposes. Do not use it for calculations.
         */
        SynapseBridge.prototype.estimateBridgeTokenOutput = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.checkSwapSupported(args)
                            .then(function () { return _this.calculateBridgeRate(args); })
                            .catch(rejectPromise)];
                });
            });
        };
        /**
         * Returns a populated transaction for initiating a token bridge between this Bridge (the source chain) and the bridge contract on the destination chain.
         * Note that this function **does not** send a signed transaction.
         * @param {BridgeTransactionParams} args Parameters for the bridge transaction
         * @param {GasOptions} gasOptions Optional gas price/fee options for the populated transaction.
         * @return {Promise<PopulatedTransaction>} Populated transaction instance which can be sent via ones choice
         * of web3/ethers/etc.
         */
        SynapseBridge.prototype.buildBridgeTokenTransaction = function (args, gasOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var addressTo, tokenArgs, tokenFrom, tokenTo, newTxn;
                var _this = this;
                return __generator(this, function (_a) {
                    addressTo = args.addressTo, tokenArgs = this.makeBridgeTokenArgs(args), tokenFrom = tokenArgs.tokenFrom, tokenTo = tokenArgs.tokenTo;
                    if ((!addressTo) || addressTo === "") {
                        return [2 /*return*/, rejectPromise(new Error("BridgeTransactionParams.addressTo cannot be empty string or undefined"))];
                    }
                    args = __assign(__assign({}, args), { tokenFrom: tokenFrom, tokenTo: tokenTo });
                    newTxn = this.chainId === ChainId.ETH
                        ? this.buildETHMainnetBridgeTxn(args, tokenArgs)
                        : this.buildL2BridgeTxn(args, tokenArgs);
                    return [2 /*return*/, newTxn
                            .then(function (txn) {
                            return GasUtils.populateGasParams(_this.chainId, txn, "bridge")
                                .then(function (txn) {
                                return gasOptions
                                    ? populateGasOptions(txn, gasOptions, _this.chainId, true)
                                    : txn;
                            });
                        })];
                });
            });
        };
        /**
         * Starts the Bridge process between this Bridge (the source chain) and the bridge contract on the destination chain.
         * Note that this function **does** send a signed transaction.
         * @param {BridgeTransactionParams} args Parameters for the bridge transaction.
         * @param {Signer} signer Some instance which implements the Ethersjs {@link Signer} interface.
         * @param {boolean} callStatic (Optional, default: false) if true, uses provider.callStatic instead of actually sending the signed transaction.
         * @return {Promise<ContractTransaction>}
         */
        SynapseBridge.prototype.executeBridgeTokenTransaction = function (args, signer, callStatic) {
            if (callStatic === void 0) { callStatic = false; }
            return __awaiter(this, void 0, void 0, function () {
                var e_1, tokenFrom, amountFrom, addressTo, signerAddress, checkArgs;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, this.checkSwapSupported(args)];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            e_1 = _a.sent();
                            return [2 /*return*/, rejectPromise(e_1)];
                        case 3:
                            tokenFrom = args.tokenFrom, amountFrom = args.amountFrom, addressTo = args.addressTo;
                            return [4 /*yield*/, signer.getAddress()];
                        case 4:
                            signerAddress = _a.sent();
                            if (!addressTo) { /* c8 ignore start */
                                args.addressTo = signerAddress;
                            } /* c8 ignore stop */
                            checkArgs = { signer: signer, token: tokenFrom, amount: amountFrom };
                            return [2 /*return*/, this.checkCanBridge(checkArgs)
                                    .then(function (canBridgeRes) {
                                    var canBridge = canBridgeRes.canBridge, reasonUnable = canBridgeRes.reasonUnable;
                                    if (!canBridge) {
                                        return rejectPromise(reasonUnable);
                                    }
                                    return _this.buildBridgeTokenTransaction(args)
                                        .then(function (txn) { return executePopulatedTransaction(txn, signer); });
                                })
                                    .catch(rejectPromise)];
                    }
                });
            });
        };
        /**
         * Builds an ethers PopulatedTransaction instance for an ERC20 Approve call,
         * approving some amount of a given token to be spent by the Synapse Bridge on its chain.
         * The returned PopulatedTransaction must then be passed to the user via Web3 or some other
         * framework so they can ultimately send the transaction.
         * Should ALWAYS be called before performing any bridge transactions to ensure they don't fail.
         * @param {Object} args
         * @param {Token|string} args.token {@link Token} instance or valid on-chain address of the token the user will be sending
         * to the bridge on the source chain.
         * @param {BigNumberish} args.amount Optional, a specific amount of args.token to approve. By default, this function
         * builds an Approve call using an "infinite" approval amount.
         * @param {GasOptions} gasOptions Optional gas price/fee options for the populated transaction.
         * @return {Promise<PopulatedTransaction>} Populated transaction instance which can be sent via ones choice
         * of web3/ethers/etc.
         */
        SynapseBridge.prototype.buildApproveTransaction = function (args, gasOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, approveArgs, tokenAddress;
                var _this = this;
                return __generator(this, function (_b) {
                    _a = this.buildERC20ApproveArgs(args), approveArgs = _a[0], tokenAddress = _a[1];
                    return [2 /*return*/, ERC20.buildApproveTransaction(approveArgs, { tokenAddress: tokenAddress, chainId: this.chainId })
                            .then(function (txn) {
                            if (gasOptions) {
                                txn = populateGasOptions(txn, gasOptions, _this.chainId);
                            }
                            return txn;
                        })];
                });
            });
        };
        /**
         * Builds and executes an ERC20 Approve call,
         * approving some amount of a given token to be spent by the Synapse Bridge on its chain.
         * The returned PopulatedTransaction must then be passed to the user via Web3 or some other
         * framework so they can ultimately send the transaction.
         * Should ALWAYS be called before performing any bridge transactions to ensure they don't fail.
         * @param {Object} args
         * @param {Token|string} args.token {@link Token} instance or valid on-chain address of the token the user will be sending
         * to the bridge on the source chain.
         * @param {BigNumberish} args.amount Optional, a specific amount of args.token to approve. By default, this function
         * @param {Signer} signer Valid ethers Signer instance for building a fully and properly populated
         * transaction.
         */
        SynapseBridge.prototype.executeApproveTransaction = function (args, signer) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, approveArgs, tokenAddress, tokenParams;
                return __generator(this, function (_b) {
                    _a = this.buildERC20ApproveArgs(args), approveArgs = _a[0], tokenAddress = _a[1], tokenParams = { tokenAddress: tokenAddress, chainId: this.chainId };
                    return [2 /*return*/, ERC20.approve(approveArgs, tokenParams, signer)];
                });
            });
        };
        SynapseBridge.prototype.getAllowanceForAddress = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var address, token, tokenAddress;
                return __generator(this, function (_a) {
                    address = args.address, token = args.token;
                    tokenAddress = token.address(this.chainId);
                    return [2 /*return*/, ERC20.allowanceOf(address, this.zapBridgeAddress, { tokenAddress: tokenAddress, chainId: this.chainId })];
                });
            });
        };
        SynapseBridge.prototype.resolveApproveFunc = function (approveRes, hasBalanceRes, token) {
            return __awaiter(this, void 0, void 0, function () {
                var needsApproval, currentAllowance, allowanceEth, errStr;
                return __generator(this, function (_a) {
                    needsApproval = approveRes.needsApproval, currentAllowance = approveRes.currentAllowance;
                    if (currentAllowance) {
                        allowanceEth = formatUnits(currentAllowance, token.decimals(this.chainId)).toString();
                    }
                    errStr = "Spend allowance of Bridge too low for token ".concat(token.symbol, "; current allowance for Bridge is ").concat(allowanceEth);
                    if (!needsApproval) {
                        return [2 /*return*/, hasBalanceRes];
                    }
                    return [2 /*return*/, { canBridge: false, reasonUnable: errStr, amount: currentAllowance }];
                });
            });
        };
        SynapseBridge.prototype.checkNeedsApprove = function (_a) {
            var address = _a.address, token = _a.token, _b = _a.amount, amount = _b === void 0 ? MAX_APPROVAL_AMOUNT.sub(1) : _b;
            return __awaiter(this, void 0, void 0, function () {
                var _c, spender, tokenAddress;
                return __generator(this, function (_d) {
                    _c = this.buildERC20ApproveArgs({ token: token, amount: amount }), spender = _c[0].spender, tokenAddress = _c[1];
                    return [2 /*return*/, ERC20.allowanceOf(address, spender, { tokenAddress: tokenAddress, chainId: this.chainId })
                            .then(function (currentAllowance) { return ({ needsApproval: currentAllowance.lt(amount), currentAllowance: currentAllowance }); })];
                });
            });
        };
        SynapseBridge.prototype.resolveBalanceFunc = function (prom, amount, token) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, Promise.resolve(prom)
                            .then(function (balance) {
                            var hasBalance = balance.gte(amount), balanceEth = formatUnits(balance, token.decimals(_this.chainId)).toString();
                            return (hasBalance
                                ? { canBridge: true }
                                : { canBridge: false, reasonUnable: "Balance of token ".concat(token.symbol, " is too low; current balance is ").concat(balanceEth), amount: balance });
                        })
                            .catch(rejectPromise)];
                });
            });
        };
        SynapseBridge.prototype.checkGasTokenBalance = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var address, token, amount, balanceProm;
                return __generator(this, function (_a) {
                    address = args.address, token = args.token, amount = args.amount;
                    balanceProm = this.provider.getBalance(address);
                    return [2 /*return*/, this.resolveBalanceFunc(balanceProm, amount, token)];
                });
            });
        };
        SynapseBridge.prototype.checkCanBridge = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var token, signer, address, signerAddress, checkArgs, isGasTokenTransfer, hasBalanceRes;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            token = args.token, signer = args.signer, address = args.address;
                            if (!(address && address !== "")) return [3 /*break*/, 1];
                            signerAddress = address;
                            return [3 /*break*/, 3];
                        case 1: return [4 /*yield*/, signer.getAddress()];
                        case 2:
                            signerAddress = _a.sent();
                            _a.label = 3;
                        case 3:
                            checkArgs = __assign(__assign({}, args), { address: signerAddress });
                            isGasTokenTransfer = (this.network.chainCurrency === token.symbol) && BridgeUtils.chainSupportsGasToken(this.chainId);
                            hasBalanceRes = isGasTokenTransfer
                                ? this.checkGasTokenBalance(checkArgs)
                                : this.checkERC20Balance(checkArgs);
                            return [2 /*return*/, isGasTokenTransfer
                                    ? hasBalanceRes
                                    : this.checkNeedsApprove(checkArgs)
                                        .then(function (approveRes) { return _this.resolveApproveFunc(approveRes, hasBalanceRes, token); })
                                        .catch(rejectPromise)];
                    }
                });
            });
        };
        SynapseBridge.prototype.checkERC20Balance = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var address, amount, token, tokenAddress;
                return __generator(this, function (_a) {
                    address = args.address, amount = args.amount, token = args.token, tokenAddress = token.address(this.chainId);
                    return [2 /*return*/, this.resolveBalanceFunc(ERC20.balanceOf(address, { tokenAddress: tokenAddress, chainId: this.chainId }), amount, token)];
                });
            });
        };
        SynapseBridge.prototype.buildERC20ApproveArgs = function (args) {
            var token = args.token, amount = args.amount;
            var spender = this.zapBridgeAddress;
            if (instanceOfToken(token) && token.isEqual(Tokens.MULTIJEWEL)) {
                spender = SynapseEntities.AvaxJewelMigrationAddress;
            }
            /* c8 ignore start */
            var tokenAddr = instanceOfToken(token)
                ? token.address(this.chainId)
                : token;
            /* c8 ignore stop */
            return [{
                    spender: spender,
                    amount: amount
                }, tokenAddr];
        };
        SynapseBridge.prototype.checkSwapSupported = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var _a = _this.swapSupported(args), swapSupported = _a[0], errReason = _a[1];
                            if (!swapSupported) {
                                reject(errReason);
                                return;
                            }
                            resolve(true);
                        })];
                });
            });
        };
        SynapseBridge.prototype.calculateBridgeRate = function (args) {
            return __awaiter(this, void 0, void 0, function () {
                var chainIdTo, amountFrom, l2BridgeZapTo, _a, tokenFrom, tokenTo, tokenIndexFrom, tokenIndexTo, fromChainTokens, intermediateToken, _b, bridgeFeeRequest, amountFromFixedDecimals, checkEthBridge, ethToEth, ethFromEth, amountToReceive_from_prom, liquidityAmounts, amountToReceive_from, bridgeFee, e_2, amountToReceive_to_prom, swapContract, amountToReceive, err_1;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            chainIdTo = args.chainIdTo, amountFrom = args.amountFrom;
                            l2BridgeZapTo = BridgeUtils.newL2BridgeZap(chainIdTo);
                            _a = this.makeBridgeTokenArgs(args), tokenFrom = _a.tokenFrom, tokenTo = _a.tokenTo, tokenIndexFrom = _a.tokenIndexFrom, tokenIndexTo = _a.tokenIndexTo, fromChainTokens = _a.fromChainTokens;
                            intermediateToken = TokenSwap.intermediateTokens(chainIdTo, tokenFrom, this.chainId).intermediateToken;
                            _b = this.bridgeConfig.calculateSwapFee({
                                chainIdFrom: this.chainId,
                                tokenFrom: tokenFrom,
                                chainIdTo: chainIdTo,
                                amountFrom: amountFrom
                            }), bridgeFeeRequest = _b.bridgeFee, amountFromFixedDecimals = _b.amountFrom;
                            checkEthBridge = function (c1, c2, t) {
                                return c1 === ChainId.ETH && BridgeUtils.isL2ETHChain(c2) && t.swapType === SwapType.ETH;
                            };
                            ethToEth = checkEthBridge(this.chainId, chainIdTo, tokenTo), ethFromEth = checkEthBridge(chainIdTo, this.chainId, tokenFrom);
                            if (amountFrom.isZero()) {
                                amountToReceive_from_prom = Promise.resolve(Zero);
                            }
                            else if (ethToEth || Tokens.isMintBurnToken(tokenFrom) || tokenFrom.isWrapperToken) {
                                amountToReceive_from_prom = Promise.resolve(amountFromFixedDecimals);
                            }
                            else if (this.chainId === ChainId.ETH) {
                                liquidityAmounts = fromChainTokens.map(function (t) {
                                    return tokenFrom.isEqual(t) ? amountFrom : Zero;
                                });
                                amountToReceive_from_prom = this.l1BridgeZapEth.calculateTokenAmount(liquidityAmounts, true);
                            }
                            else {
                                amountToReceive_from_prom = this.l2BridgeZap.calculateSwap(intermediateToken.address(this.chainId), tokenIndexFrom, 0, amountFrom);
                            }
                            return [4 /*yield*/, amountToReceive_from_prom];
                        case 1:
                            amountToReceive_from = _c.sent();
                            _c.label = 2;
                        case 2:
                            _c.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, bridgeFeeRequest];
                        case 3:
                            bridgeFee = _c.sent();
                            if (bridgeFee === null) {
                                console.error("calculateSwapFee returned null");
                                return [2 /*return*/, rejectPromise("calculateSwapFee returned null")];
                            }
                            return [3 /*break*/, 5];
                        case 4:
                            e_2 = _c.sent();
                            console.error("Error in bridge fee request: ".concat(e_2));
                            return [2 /*return*/, rejectPromise(e_2)];
                        case 5:
                            amountToReceive_from = BridgeUtils.subBigNumSafe(amountToReceive_from, bridgeFee);
                            if (!amountToReceive_from.isZero()) return [3 /*break*/, 6];
                            amountToReceive_to_prom = Promise.resolve(Zero);
                            return [3 /*break*/, 11];
                        case 6:
                            if (!(ethFromEth || Tokens.isMintBurnToken(tokenTo) || tokenTo.isWrapperToken)) return [3 /*break*/, 7];
                            amountToReceive_to_prom = Promise.resolve(amountToReceive_from);
                            return [3 /*break*/, 11];
                        case 7:
                            if (!(chainIdTo === ChainId.ETH)) return [3 /*break*/, 8];
                            amountToReceive_to_prom =
                                this.l1BridgeZapEth.calculateRemoveLiquidityOneToken(amountToReceive_from, tokenIndexTo);
                            return [3 /*break*/, 11];
                        case 8:
                            if (!(chainIdTo === ChainId.CRONOS)) return [3 /*break*/, 10];
                            return [4 /*yield*/, TokenSwap.swapContract(intermediateToken, chainIdTo)];
                        case 9:
                            swapContract = _c.sent();
                            amountToReceive_to_prom = swapContract.calculateSwap(0, tokenIndexTo, amountToReceive_from);
                            return [3 /*break*/, 11];
                        case 10:
                            amountToReceive_to_prom = l2BridgeZapTo.calculateSwap(intermediateToken.address(chainIdTo), 0, tokenIndexTo, amountToReceive_from);
                            _c.label = 11;
                        case 11:
                            _c.trys.push([11, 13, , 14]);
                            return [4 /*yield*/, Promise.resolve(amountToReceive_to_prom)];
                        case 12:
                            amountToReceive = _c.sent();
                            return [3 /*break*/, 14];
                        case 13:
                            err_1 = _c.sent();
                            return [2 /*return*/, rejectPromise(err_1)];
                        case 14: /* c8 ignore stop */ return [2 /*return*/, { amountToReceive: amountToReceive, bridgeFee: bridgeFee }];
                    }
                });
            });
        };
        SynapseBridge.prototype.checkEasyArgs = function (args, zapBridge, easyDeposits, easyRedeems, easyDepositETH) {
            var _a, _b, _c;
            var castArgs = args, isEasy = false, txn;
            var params = BridgeUtils.makeEasyParams(castArgs, this.chainId, args.tokenTo);
            switch (true) {
                case easyRedeems.includes(args.tokenTo.id):
                    isEasy = true;
                    txn = (_a = zapBridge.populateTransaction).redeem.apply(_a, params);
                    break;
                case easyDeposits.includes(args.tokenTo.id):
                    isEasy = true;
                    txn = (_b = zapBridge.populateTransaction).deposit.apply(_b, params);
                    break;
                case easyDepositETH.includes(args.tokenTo.id):
                    isEasy = true;
                    txn = (_c = zapBridge
                        .populateTransaction)
                        .depositETH.apply(_c, __spreadArray(__spreadArray([], BridgeUtils.depositETHParams(castArgs), false), [BridgeUtils.overrides(args.amountFrom)], false));
                    break;
            }
            return { castArgs: castArgs, isEasy: isEasy, txn: txn };
        };
        SynapseBridge.prototype.buildETHMainnetBridgeTxn = function (args, tokenArgs) {
            var _a, _b;
            var addressTo = args.addressTo, chainIdTo = args.chainIdTo, amountFrom = args.amountFrom, amountTo = args.amountTo;
            var easyRedeems = [
                Tokens.SYN.id, Tokens.UST.id, Tokens.USDB.id,
                Tokens.VSTA.id,
            ], easyDeposits = [
                Tokens.HIGH.id, Tokens.DOG.id, Tokens.FRAX.id,
                Tokens.GOHM.id, Tokens.NEWO.id, Tokens.SDT.id,
            ], easyDepositETH = [Tokens.NETH.id];
            var _c = this.checkEasyArgs(args, this.l1BridgeZapEth, easyDeposits, easyRedeems, easyDepositETH), castArgs = _c.castArgs, isEasy = _c.isEasy, txn = _c.txn;
            if (isEasy && txn) {
                return txn;
            }
            var liquidityAmounts = tokenArgs.fromChainTokens.map(function (t) {
                return args.tokenFrom.isEqual(t)
                    ? amountFrom
                    : Zero;
            });
            var _d = BridgeUtils.getSlippages(amountFrom, amountTo), transactionDeadline = _d.transactionDeadline, bridgeTransactionDeadline = _d.bridgeTransactionDeadline, minToSwapDestFromOrigin = _d.minToSwapDestFromOrigin, minToSwapDest = _d.minToSwapDest, minToSwapOriginMediumSlippage = _d.minToSwapOriginMediumSlippage, minToSwapDestFromOriginMediumSlippage = _d.minToSwapDestFromOriginMediumSlippage;
            if (args.tokenTo.isEqual(Tokens.NUSD) || args.tokenTo.isEqual(Tokens.DFK_USDC)) {
                if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC)) {
                    var bridgeDepositArgs = BridgeUtils.makeEasyParams(args, this.chainId, Tokens.NUSD);
                    return (_a = this.l1BridgeZapEth
                        .populateTransaction)
                        .deposit.apply(_a, bridgeDepositArgs);
                }
                else {
                    return this.l1BridgeZapEth.populateTransaction.zapAndDeposit(addressTo, chainIdTo, Tokens.NUSD.address(this.chainId), liquidityAmounts, minToSwapDest, transactionDeadline);
                }
            }
            if (BridgeUtils.isETHLikeToken(args.tokenTo) || args.tokenTo.isEqual(Tokens.WETH)) {
                return (_b = this.l1BridgeZapEth.populateTransaction).depositETHAndSwap.apply(_b, __spreadArray(__spreadArray([], BridgeUtils.depositETHParams(castArgs), false), [0,
                    tokenArgs.tokenIndexTo,
                    minToSwapDestFromOrigin,
                    bridgeTransactionDeadline,
                    BridgeUtils.overrides(amountFrom)], false));
            }
            else if (args.tokenFrom.isEqual(Tokens.NUSD)) {
                return this.l1BridgeZapEth.populateTransaction.depositAndSwap(addressTo, chainIdTo, Tokens.NUSD.address(this.chainId), amountFrom, 0, tokenArgs.tokenIndexTo, minToSwapDestFromOriginMediumSlippage, bridgeTransactionDeadline);
            }
            return this.l1BridgeZapEth.populateTransaction.zapAndDepositAndSwap(addressTo, chainIdTo, Tokens.NUSD.address(this.chainId), liquidityAmounts, minToSwapOriginMediumSlippage, // minToSwapOrigin,
            transactionDeadline, 0, tokenArgs.tokenIndexTo, minToSwapDestFromOriginMediumSlippage, //, minToSwapDestFromOrigin, // minDy
            bridgeTransactionDeadline);
        };
        SynapseBridge.prototype.buildL2BridgeTxn = function (args, tokenArgs) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            var _this = this;
            var chainIdTo = args.chainIdTo, amountFrom = args.amountFrom, amountTo = args.amountTo, zapBridge = SynapseEntities.L2BridgeZapContractInstance({
                chainId: this.chainId,
                signerOrProvider: this.provider
            });
            tokenArgs.tokenFrom = tokenArgs.tokenFrom.isEqual(Tokens.AVWETH)
                ? Tokens.WETH_E
                : tokenArgs.tokenFrom;
            if (tokenArgs.tokenFrom.isEqual(Tokens.MULTIJEWEL)) {
                var jewelMigrator = SynapseEntities.AvaxJewelMigrationContractInstance();
                return jewelMigrator
                    .populateTransaction
                    .migrateAndBridge(args.amountFrom, args.addressTo, args.chainIdTo);
            }
            var easyDeposits = [], easyDepositETH = [], easyRedeems = [
                Tokens.SYN.id, Tokens.HIGH.id, Tokens.DOG.id,
                Tokens.FRAX.id, Tokens.UST.id, Tokens.GOHM.id,
                Tokens.NEWO.id, Tokens.SDT.id, Tokens.LUNA.id,
                Tokens.USDB.id,
            ];
            BridgeUtils.DepositIfChainTokens.forEach(function (depositIfChainArgs) {
                if (_this.chainId === ChainId.DFK && args.tokenTo.isEqual(Tokens.SYN_AVAX)) {
                    return;
                }
                var chainId = depositIfChainArgs.chainId, tokens = depositIfChainArgs.tokens, depositEth = depositIfChainArgs.depositEth, redeemChainIds = depositIfChainArgs.redeemChainIds;
                var hasAltChains = redeemChainIds.length > 0, tokenHashes = tokens.map(function (t) { return t.id; });
                if (_this.chainId === chainId) {
                    if (depositEth) {
                        easyDepositETH.push.apply(easyDepositETH, tokenHashes);
                    }
                    else {
                        easyDeposits.push.apply(easyDeposits, tokenHashes);
                    }
                }
                else {
                    if (hasAltChains && redeemChainIds.includes(_this.chainId)) {
                        easyRedeems.push.apply(easyRedeems, tokenHashes);
                    }
                }
            });
            var dfkBridgeZap = BridgeUtils.newL1BridgeZap(ChainId.DFK), checkEasyZap = this.chainId === ChainId.DFK ? dfkBridgeZap : this.zapBridge;
            var _l = this.checkEasyArgs(args, checkEasyZap, easyDeposits, easyRedeems, easyDepositETH), castArgs = _l.castArgs, isEasy = _l.isEasy, txn = _l.txn;
            if (isEasy && txn) {
                return txn;
            }
            var _m = BridgeUtils.getSlippages(amountFrom, amountTo), transactionDeadline = _m.transactionDeadline, bridgeTransactionDeadline = _m.bridgeTransactionDeadline, minToSwapDestFromOrigin = _m.minToSwapDestFromOrigin, minToSwapOriginHighSlippage = _m.minToSwapOriginHighSlippage, minToSwapDestFromOriginMediumSlippage = _m.minToSwapDestFromOriginMediumSlippage, minToSwapDestFromOriginHighSlippage = _m.minToSwapDestFromOriginHighSlippage, minToSwapDest = _m.minToSwapDest;
            var easyRedeemAndSwap = function (baseToken) {
                var _a;
                return (_a = zapBridge
                    .populateTransaction)
                    .redeemAndSwap.apply(_a, __spreadArray(__spreadArray([], BridgeUtils.makeEasyParams(castArgs, _this.chainId, baseToken), false), [0,
                    tokenArgs.tokenIndexTo,
                    minToSwapDest,
                    transactionDeadline], false));
            };
            var easySwapAndRedeem = function (baseToken, swapETH) {
                if (swapETH === void 0) { swapETH = false; }
                var populateFn = swapETH
                    ? zapBridge.populateTransaction.swapETHAndRedeem
                    : zapBridge.populateTransaction.swapAndRedeem;
                return populateFn.apply(void 0, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, _this.chainId, baseToken), false), [tokenArgs.tokenIndexFrom,
                    0,
                    amountFrom,
                    minToSwapOriginHighSlippage,
                    transactionDeadline,
                    swapETH ? BridgeUtils.overrides(amountFrom) : {}], false));
            };
            var easySwapAndRedeemAndSwap = function (baseToken, swapETH) {
                if (swapETH === void 0) { swapETH = false; }
                var populateFn = swapETH
                    ? zapBridge.populateTransaction.swapETHAndRedeemAndSwap
                    : zapBridge.populateTransaction.swapAndRedeemAndSwap;
                return populateFn.apply(void 0, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, _this.chainId, baseToken), false), [tokenArgs.tokenIndexFrom,
                    0,
                    amountFrom,
                    minToSwapOriginHighSlippage,
                    transactionDeadline,
                    0,
                    tokenArgs.tokenIndexTo,
                    minToSwapDestFromOriginHighSlippage,
                    bridgeTransactionDeadline,
                    swapETH ? BridgeUtils.overrides(amountFrom) : {}], false));
            };
            switch (tokenSwitch(args.tokenTo)) {
                case Tokens.NUSD:
                case Tokens.DFK_USDC:
                    if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC)) {
                        return (_a = zapBridge
                            .populateTransaction)
                            .redeem.apply(_a, BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.NUSD));
                    }
                    return (_b = zapBridge
                        .populateTransaction)
                        .swapAndRedeem.apply(_b, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.NUSD), false), [tokenArgs.tokenIndexFrom,
                        0,
                        amountFrom,
                        minToSwapOriginHighSlippage,
                        transactionDeadline], false));
                case Tokens.GMX:
                    var params = BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.GMX);
                    var addrTo = params[0], chainTo = params[1], amount = params[3];
                    return this.chainId === ChainId.ARBITRUM
                        ? (_c = zapBridge.populateTransaction).deposit.apply(_c, params) : this.bridgeInstance
                        .populateTransaction
                        .redeem(addrTo, chainTo, Tokens.GMX.wrapperAddress(this.chainId), amount);
                case Tokens.JEWEL:
                    if (this.chainId === ChainId.HARMONY) {
                        return (_d = zapBridge
                            .populateTransaction)
                            .swapAndRedeem.apply(_d, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.SYN_JEWEL), false), [0,
                            1,
                            amountFrom,
                            minToSwapOriginHighSlippage,
                            transactionDeadline], false));
                    }
                    else if (this.chainId === ChainId.DFK) {
                        if (args.chainIdTo === ChainId.HARMONY) {
                            return dfkBridgeZap.populateTransaction.depositETHAndSwap(args.addressTo, args.chainIdTo, args.amountFrom, 1, 0, minToSwapDestFromOriginMediumSlippage, bridgeTransactionDeadline, BridgeUtils.overrides(args.amountFrom));
                        }
                        return dfkBridgeZap.populateTransaction.depositETH(args.addressTo, args.chainIdTo, args.amountFrom, BridgeUtils.overrides(args.amountFrom));
                    }
                    if (chainIdTo === ChainId.DFK) {
                        return zapBridge.populateTransaction.redeem(args.addressTo, ChainId.DFK, Tokens.JEWEL.address(this.chainId), args.amountFrom);
                    }
                    return zapBridge.populateTransaction.redeemAndSwap(args.addressTo, args.chainIdTo, Tokens.JEWEL.address(this.chainId), args.amountFrom, 1, 0, minToSwapDest, transactionDeadline);
                case Tokens.SYN_JEWEL:
                    if (this.chainId === ChainId.DFK) {
                        return dfkBridgeZap
                            .populateTransaction
                            .depositETH(args.addressTo, args.chainIdTo, args.amountFrom, BridgeUtils.overrides(args.amountFrom));
                    }
                    return (_e = zapBridge
                        .populateTransaction)
                        .swapAndRedeem.apply(_e, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.JEWEL), false), [0,
                        1,
                        amountFrom,
                        minToSwapOriginHighSlippage,
                        transactionDeadline], false));
                case Tokens.SYN_AVAX:
                    if (this.chainId === ChainId.DFK) {
                        return (_f = dfkBridgeZap
                            .populateTransaction)
                            .redeem.apply(_f, BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.WAVAX));
                    }
                    /* c8 ignore next */
                    break;
                case Tokens.MULTI_AVAX:
                    switch (this.chainId) {
                        case ChainId.DFK:
                            return dfkBridgeZap
                                .populateTransaction
                                .redeemAndSwap(castArgs.addressTo, castArgs.chainIdTo, Tokens.WAVAX.address(this.chainId), castArgs.amountFrom, 0, tokenArgs.tokenIndexTo, minToSwapDest, transactionDeadline);
                        case ChainId.MOONBEAM:
                            return this.l2BridgeZap
                                .populateTransaction
                                .redeemAndSwap(castArgs.addressTo, castArgs.chainIdTo, Tokens.WAVAX.address(this.chainId), castArgs.amountFrom, 0, tokenArgs.tokenIndexTo, minToSwapDest, transactionDeadline);
                        default:
                            return this.l2BridgeZap
                                .populateTransaction
                                .depositETHAndSwap(castArgs.addressTo, // to address
                            castArgs.chainIdTo, // to chainId
                            castArgs.amountFrom, 0, // tokenIndexFrom for nusd
                            tokenArgs.tokenIndexTo, // tokenIndexTo + 1,
                            minToSwapDestFromOrigin, // minDy
                            bridgeTransactionDeadline, BridgeUtils.overrides(castArgs.amountFrom));
                    }
                default:
                    if (chainIdTo === ChainId.ETH) {
                        if (this.isL2ETHChain && args.tokenFrom.swapType === SwapType.ETH) {
                            if (args.tokenFrom.isEqual(Tokens.NETH)) {
                                return (_g = zapBridge
                                    .populateTransaction)
                                    .redeem.apply(_g, BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.NETH));
                            }
                            else {
                                var useSwapETH = !BridgeUtils.isETHLikeToken(args.tokenFrom);
                                return easySwapAndRedeem(Tokens.NETH, useSwapETH);
                            }
                        }
                        else if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC)) {
                            return (_h = zapBridge
                                .populateTransaction)
                                .redeemAndRemove.apply(_h, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.NUSD), false), [amountFrom,
                                tokenArgs.tokenIndexTo,
                                minToSwapDest,
                                transactionDeadline], false));
                        }
                        return (_j = zapBridge
                            .populateTransaction)
                            .swapAndRedeemAndRemove.apply(_j, __spreadArray(__spreadArray([], BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.NUSD), false), [tokenArgs.tokenIndexFrom,
                            0,
                            amountFrom,
                            minToSwapOriginHighSlippage,
                            transactionDeadline,
                            tokenArgs.tokenIndexTo,
                            minToSwapDestFromOriginHighSlippage,
                            bridgeTransactionDeadline], false));
                    }
                    if (this.chainId === ChainId.HARMONY) {
                        if (args.tokenFrom.isEqual(Tokens.SYN_AVAX)) {
                            var redeemArgs = BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.SYN_AVAX);
                            return (_k = zapBridge
                                .populateTransaction)
                                .redeem.apply(_k, redeemArgs);
                        }
                        else if (args.tokenFrom.isEqual(Tokens.MULTI_AVAX)) {
                            return zapBridge
                                .populateTransaction
                                .swapAndRedeem(castArgs.addressTo, castArgs.chainIdTo, Tokens.SYN_AVAX.address(this.chainId), tokenArgs.tokenIndexFrom, 0, castArgs.amountFrom, minToSwapOriginHighSlippage, transactionDeadline);
                        }
                    }
                    if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC) || args.tokenFrom.isEqual(Tokens.NETH)) {
                        return easyRedeemAndSwap(args.tokenFrom);
                    }
                    if (args.tokenFrom.swapType === SwapType.ETH) {
                        var useSwapETH = !BridgeUtils.isETHLikeToken(args.tokenFrom);
                        return easySwapAndRedeemAndSwap(Tokens.NETH, useSwapETH);
                    }
                    return easySwapAndRedeemAndSwap(Tokens.NUSD);
            }
        };
        SynapseBridge.prototype.makeBridgeTokenArgs = function (args) {
            var _a;
            var tokenFrom = args.tokenFrom, tokenTo = args.tokenTo, chainIdTo = args.chainIdTo;
            var bridgeTokens;
            switch (tokenFrom.swapType) {
                case SwapType.ETH:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.ETH, Tokens.WETH);
                    break;
                case SwapType.AVAX:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.AVAX, Tokens.WAVAX);
                    break;
                case SwapType.MOVR:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.MOVR, Tokens.WMOVR);
                    break;
                case SwapType.JEWEL:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.GAS_JEWEL, Tokens.JEWEL);
                    break;
                default:
                    bridgeTokens = function (t1, t2) { return [t1, t2]; };
            }
            _a = bridgeTokens(tokenFrom, tokenTo), tokenFrom = _a[0], tokenTo = _a[1];
            var _b = BridgeUtils.makeTokenArgs(this.chainId, tokenFrom), fromChainTokens = _b[0], tokenIndexFrom = _b[1], _c = BridgeUtils.makeTokenArgs(chainIdTo, tokenTo), toChainTokens = _c[0], tokenIndexTo = _c[1];
            return {
                fromChainTokens: fromChainTokens,
                toChainTokens: toChainTokens,
                tokenFrom: tokenFrom,
                tokenTo: tokenTo,
                tokenIndexFrom: tokenIndexFrom,
                tokenIndexTo: tokenIndexTo
            };
        };
        return SynapseBridge;
    }());
    Bridge.SynapseBridge = SynapseBridge;
    var REQUIRED_CONFS = (_a = {},
        _a[ChainId.ETH] = 7,
        _a[ChainId.OPTIMISM] = 1,
        _a[ChainId.CRONOS] = 6,
        _a[ChainId.BSC] = 14,
        _a[ChainId.POLYGON] = 128,
        _a[ChainId.FANTOM] = 5,
        _a[ChainId.BOBA] = 1,
        _a[ChainId.METIS] = 6,
        _a[ChainId.MOONBEAM] = 21,
        _a[ChainId.MOONRIVER] = 21,
        _a[ChainId.ARBITRUM] = 40,
        _a[ChainId.AVALANCHE] = 5,
        _a[ChainId.DFK] = 1,
        _a[ChainId.HARMONY] = 1,
        _a[ChainId.AURORA] = 5,
        _a);
    function getRequiredConfirmationsForBridge(network) {
        var chainId = network instanceof Networks.Network ? network.chainId : network;
        if (chainId in REQUIRED_CONFS) {
            return REQUIRED_CONFS[chainId];
        }
        return null;
    }
    Bridge.getRequiredConfirmationsForBridge = getRequiredConfirmationsForBridge;
    function bridgeSwapSupported(args) {
        return TokenSwap.bridgeSwapSupported(args);
    }
    Bridge.bridgeSwapSupported = bridgeSwapSupported;
    function checkBridgeTransactionComplete(args) {
        var chainIdTo = args.chainIdTo, transactionHashChainFrom = args.transactionHashChainFrom, kappa = makeKappa(transactionHashChainFrom), bridgeInstance = new SynapseBridge({ network: chainIdTo });
        return bridgeInstance.kappaExists(kappa)
            .then(function (res) { return res; })
            .catch(rejectPromise);
    }
    Bridge.checkBridgeTransactionComplete = checkBridgeTransactionComplete;
})(Bridge || (Bridge = {}));
