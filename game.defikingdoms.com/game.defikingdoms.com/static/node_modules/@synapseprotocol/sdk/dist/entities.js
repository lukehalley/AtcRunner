import { SynapseBridgeFactory, L1BridgeZapFactory, L2BridgeZapFactory, BridgeConfigV3Factory, AvaxJewelMigrationFactory } from "./contracts.js";
import { ChainId } from "./common/chainid.js";
import { contractAddressFor } from "./common/utils.js";
import { rpcProviderForChain } from "./internal/rpcproviders.js";
const bridgeConfigV3Address = "0x5217c83ca75559B1f8a8803824E5b7ac233A12a1";
export const AvaxJewelMigrationAddress = "0x82d4aCF0DA013Ee3649C7eAdF5Db9093A7EFa7B0";
var ContractKind;
(function (ContractKind) {
    ContractKind["bridge"] = "bridgeAddress";
    ContractKind["bridgeZap"] = "bridgeZapAddress";
})(ContractKind || (ContractKind = {}));
var EntityKind;
(function (EntityKind) {
    EntityKind["SynapseBridge"] = "SynapseBridge";
    EntityKind["L1BridgeZap"] = "L1BridgeZap";
    EntityKind["L2BridgeZap"] = "L2BridgeZap";
    EntityKind["BridgeConfig"] = "BridgeConfig";
    EntityKind["AvaxJewelMigration"] = "AvaxJewelMigration";
})(EntityKind || (EntityKind = {}));
var Connector;
(function (Connector) {
    function makeConnectorName(chainId, entityKind) {
        return `${entityKind.toString()}.${chainId}`;
    }
    class EntityConnector {
        entityMap;
        constructor() {
            this.entityMap = {};
        }
        addEntity(connectorName, contract, entityKind, chainId) {
            this.entityMap[connectorName] = { contract, entityKind, chainId };
        }
        checkEntity(connectorName) {
            if (connectorName in this.entityMap) {
                return this.entityMap[connectorName].contract;
            }
        }
        synapseBridge(params) {
            const { chainId, signerOrProvider } = params, entityKind = EntityKind.SynapseBridge, connectorName = makeConnectorName(chainId, entityKind);
            const check = this.checkEntity(connectorName);
            if (check) {
                return check;
            }
            const newEntity = SynapseBridgeFactory.connect(contractAddressFor(chainId, ContractKind.bridge), signerOrProvider);
            this.addEntity(connectorName, newEntity, entityKind, chainId);
            return newEntity;
        }
        l1BridgeZap(params) {
            const { chainId, signerOrProvider } = params, entityKind = EntityKind.L1BridgeZap, connectorName = makeConnectorName(chainId, entityKind);
            const check = this.checkEntity(connectorName);
            if (check) {
                return check;
            }
            const newEntity = L1BridgeZapFactory.connect(contractAddressFor(chainId, ContractKind.bridgeZap), signerOrProvider);
            this.addEntity(connectorName, newEntity, entityKind, chainId);
            return newEntity;
        }
        l2BridgeZap(params) {
            const { chainId, signerOrProvider } = params, entityKind = EntityKind.L2BridgeZap, connectorName = makeConnectorName(chainId, entityKind);
            const check = this.checkEntity(connectorName);
            if (check) {
                return check;
            }
            const newEntity = L2BridgeZapFactory.connect(contractAddressFor(chainId, ContractKind.bridgeZap), signerOrProvider);
            this.addEntity(connectorName, newEntity, entityKind, chainId);
            return newEntity;
        }
        bridgeConfig() {
            const chainId = ChainId.ETH, entityKind = EntityKind.BridgeConfig, connectorName = makeConnectorName(chainId, entityKind);
            const check = this.checkEntity(connectorName);
            if (check) {
                return check;
            }
            const newEntity = BridgeConfigV3Factory.connect(bridgeConfigV3Address, rpcProviderForChain(chainId));
            this.addEntity(connectorName, newEntity, entityKind, chainId);
            return newEntity;
        }
        avaxJewelMigration() {
            const chainId = ChainId.AVALANCHE, entityKind = EntityKind.AvaxJewelMigration, connectorName = makeConnectorName(chainId, entityKind);
            const check = this.checkEntity(connectorName);
            if (check) {
                return check;
            }
            const newEntity = AvaxJewelMigrationFactory.connect(AvaxJewelMigrationAddress, rpcProviderForChain(ChainId.AVALANCHE));
            this.addEntity(connectorName, newEntity, entityKind, chainId);
            return newEntity;
        }
    }
    Connector.EntityConnector = EntityConnector;
})(Connector || (Connector = {}));
const ENTITY_CONNECTOR = new Connector.EntityConnector();
export function SynapseBridgeContractInstance(params) {
    return ENTITY_CONNECTOR.synapseBridge(params);
}
export function L1BridgeZapContractInstance(params) {
    return ENTITY_CONNECTOR.l1BridgeZap(params);
}
export function L2BridgeZapContractInstance(params) {
    return ENTITY_CONNECTOR.l2BridgeZap(params);
}
export function GenericZapBridgeContractInstance(params) {
    return params.chainId === ChainId.ETH || params.chainId === ChainId.DFK
        ? L1BridgeZapContractInstance(params)
        : L2BridgeZapContractInstance(params);
}
export function BridgeConfigV3ContractInstance() {
    return ENTITY_CONNECTOR.bridgeConfig();
}
export function AvaxJewelMigrationContractInstance() {
    return ENTITY_CONNECTOR.avaxJewelMigration();
}
