import { Slippages } from "./slippages.js";
import { Tokens } from "../tokens.js";
import { ChainId } from "../common/chainid.js";
import { SwapPools } from "../swappools.js";
import * as SynapseEntities from "../entities.js";
import { tokenSwitch } from "../internal/utils.js";
import { rpcProviderForChain } from "../internal/rpcproviders.js";
import { Zero } from "@ethersproject/constants";
export var BridgeUtils;
(function (BridgeUtils) {
    BridgeUtils.L2_ETH_CHAINS = [
        ChainId.OPTIMISM,
        ChainId.FANTOM,
        ChainId.BOBA,
        ChainId.METIS,
        ChainId.MOONBEAM,
        ChainId.ARBITRUM,
        ChainId.AVALANCHE,
        ChainId.HARMONY,
    ];
    BridgeUtils.GAS_TOKEN_CHAINS = [
        ChainId.ETH,
        ChainId.OPTIMISM,
        ChainId.BOBA,
        ChainId.ARBITRUM,
        ChainId.AVALANCHE,
        ChainId.DFK
    ];
    BridgeUtils.isL2ETHChain = (chainId) => BridgeUtils.L2_ETH_CHAINS.includes(chainId);
    BridgeUtils.chainSupportsGasToken = (chainId) => BridgeUtils.GAS_TOKEN_CHAINS.includes(chainId);
    BridgeUtils.DepositIfChainTokens = [
        { chainId: ChainId.FANTOM, tokens: [Tokens.JUMP], redeemChainIds: [ChainId.BSC], depositEth: false },
        { chainId: ChainId.POLYGON, tokens: [Tokens.NFD], redeemChainIds: [], depositEth: false },
        { chainId: ChainId.MOONRIVER, tokens: [Tokens.SOLAR], redeemChainIds: [], depositEth: false },
        {
            chainId: ChainId.AVALANCHE,
            tokens: [Tokens.AVAX, Tokens.WAVAX, Tokens.SYN_AVAX],
            redeemChainIds: [ChainId.MOONBEAM, ChainId.DFK],
            depositEth: true
        },
        { chainId: ChainId.MOONRIVER, tokens: [Tokens.MOVR, Tokens.WMOVR], redeemChainIds: [ChainId.MOONBEAM], depositEth: true },
        {
            chainId: ChainId.HARMONY,
            tokens: [Tokens.XJEWEL],
            redeemChainIds: [ChainId.DFK],
            depositEth: false,
        },
    ];
    function getBridgeTxArgs() {
        return {
            slippageCustom: null,
            slippageSelected: Slippages.OneTenth,
            infiniteApproval: true,
            transactionDeadline: BridgeUtils.getTimeMinutesFromNow(10),
            bridgeTransactionDeadline: BridgeUtils.getTimeMinutesFromNow(60 * 24)
        };
    }
    BridgeUtils.getBridgeTxArgs = getBridgeTxArgs;
    function getSlippages(amountFrom, amountTo) {
        const { slippageSelected, transactionDeadline, bridgeTransactionDeadline } = getBridgeTxArgs();
        const selectedGasArgs = slippageSelected, twoTenthGasArgs = Slippages.TwoTenth, quarterGasArgs = Slippages.Quarter;
        const minToSwapOrigin = Slippages.subtractSlippage(amountFrom, selectedGasArgs), minToSwapDest = Slippages.subtractSlippage(amountTo, selectedGasArgs), minToSwapDestFromOrigin = Slippages.subtractSlippage(minToSwapDest, selectedGasArgs);
        const minToSwapOriginMediumSlippage = Slippages.subtractSlippage(amountFrom, twoTenthGasArgs), minToSwapDestMediumSlippage = Slippages.subtractSlippage(amountTo, twoTenthGasArgs), minToSwapDestFromOriginMediumSlippage = Slippages.subtractSlippage(minToSwapDestMediumSlippage, twoTenthGasArgs);
        const minToSwapOriginHighSlippage = Slippages.subtractSlippage(amountFrom, quarterGasArgs), minToSwapDestHighSlippage = Slippages.subtractSlippage(amountTo, quarterGasArgs), minToSwapDestFromOriginHighSlippage = Slippages.subtractSlippage(minToSwapDestHighSlippage, quarterGasArgs);
        return {
            slippageSelected,
            transactionDeadline,
            bridgeTransactionDeadline,
            minToSwapOrigin,
            minToSwapDest,
            minToSwapDestFromOrigin,
            minToSwapOriginMediumSlippage,
            minToSwapDestMediumSlippage,
            minToSwapDestFromOriginMediumSlippage,
            minToSwapOriginHighSlippage,
            minToSwapDestHighSlippage,
            minToSwapDestFromOriginHighSlippage,
        };
    }
    BridgeUtils.getSlippages = getSlippages;
    BridgeUtils.entityParams = (chainId) => ({ chainId, signerOrProvider: rpcProviderForChain(chainId) });
    BridgeUtils.newL1BridgeZap = (chainId) => SynapseEntities.L1BridgeZapContractInstance(BridgeUtils.entityParams(chainId)), BridgeUtils.newL2BridgeZap = (chainId) => SynapseEntities.L2BridgeZapContractInstance(BridgeUtils.entityParams(chainId)), BridgeUtils.newBridgeZap = (chainId) => SynapseEntities.GenericZapBridgeContractInstance(BridgeUtils.entityParams(chainId));
    BridgeUtils.subBigNumSafe = (a, b) => a.gt(b) ? a.sub(b) : Zero;
    BridgeUtils.getTimeMinutesFromNow = (minutesFromNow) => Math.round((new Date().getTime() / 1000) + 60 * minutesFromNow);
    BridgeUtils.makeEasyParams = (args, chainId, t) => [args.addressTo, args.chainIdTo, t.address(chainId), args.amountFrom];
    BridgeUtils.makeEasySubParams = (args, chainId, t) => {
        let x = BridgeUtils.makeEasyParams(args, chainId, t);
        return [x[0], x[1], x[2]];
    };
    BridgeUtils.depositETHParams = (args) => [args.addressTo, args.chainIdTo, args.amountFrom];
    async function calculateSwapL2Zap(zapBridge, intermediateToken, tokenIndexFrom, tokenIndexTo, amount) {
        return zapBridge.calculateSwap(intermediateToken, tokenIndexFrom, tokenIndexTo, amount);
    }
    BridgeUtils.calculateSwapL2Zap = calculateSwapL2Zap;
    BridgeUtils.isETHLikeToken = (t) => [Tokens.WETH_E.id, Tokens.ONE_ETH.id, Tokens.FTM_ETH.id, Tokens.METIS_ETH.id].includes(t.id);
    BridgeUtils.overrides = (value) => ({ value });
    /**
     * Switch t1 with t3 is t1 is t2
     * @param {Token} t1 token being checked
     * @param {Token} t2 token to check t1 against
     * @param {Token} t3 token to return instead of t1 if t1 equals t2
     */
    const checkReplaceToken = (t1, t2, t3) => t1.isEqual(t2) ? t3 : t1;
    BridgeUtils.checkReplaceTokens = (check, replace) => (t1, t2) => [
        checkReplaceToken(t1, check, replace),
        checkReplaceToken(t2, check, replace)
    ];
    function findSymbol(t1, t2, chainId) {
        let compare = t2;
        switch (tokenSwitch(t2)) {
            case Tokens.WETH_E:
                compare = Tokens.AVWETH;
                break;
            case Tokens.WETH:
                compare = Tokens.WETH;
                break;
            case Tokens.JEWEL:
                if (chainId === ChainId.HARMONY) {
                    compare = Tokens.SYN_JEWEL;
                }
                else {
                    compare = t2.underlyingToken;
                }
                break;
            case Tokens.WAVAX:
                if (chainId !== ChainId.DFK) {
                    compare = t2.underlyingToken;
                }
                break;
            default:
                if (t2.isWrapperToken && t2.underlyingToken) {
                    compare = t2.underlyingToken;
                }
                break;
        }
        return t1.isEqual(compare);
    }
    function makeTokenArgs(chainId, t) {
        let toks = SwapPools.bridgeSwappableMap[chainId].swappableSwapGroups[t.swapType].poolTokens, idx = toks.findIndex((tok) => findSymbol(tok, t, chainId));
        return [toks, idx];
    }
    BridgeUtils.makeTokenArgs = makeTokenArgs;
})(BridgeUtils || (BridgeUtils = {}));
