import { ChainId } from "../common/chainid.js";
import { Networks } from "../common/networks.js";
import { instanceOfToken } from "../token.js";
import { Tokens } from "../tokens.js";
import { TokenSwap } from "../tokenswap.js";
import { rejectPromise, executePopulatedTransaction } from "../common/utils.js";
import { SynapseContracts } from "../common/synapse_contracts.js";
import { SwapType } from "../internal/swaptype.js";
import { rpcProviderForChain } from "../internal/rpcproviders.js";
import { tokenSwitch } from "../internal/utils.js";
import * as SynapseEntities from "../entities.js";
import { BridgeConfig } from "./bridgeconfig.js";
import { GasUtils } from "./gasutils.js";
import { BridgeUtils } from "./bridgeutils.js";
import { ERC20, MAX_APPROVAL_AMOUNT } from "./erc20.js";
import { id as makeKappa } from "@ethersproject/hash";
import { Zero } from "@ethersproject/constants";
import { formatUnits } from "@ethersproject/units";
/**
 * Bridge provides a wrapper around common Synapse Bridge interactions, such as output estimation, checking supported swaps/bridges,
 * and most importantly, executing Bridge transactions.
 */
export var Bridge;
(function (Bridge) {
    /**
     * SynapseBridge is a wrapper around any Synapse Bridge contract which exists on chains supported by the Synapse Protocol.
     */
    class SynapseBridge {
        network;
        chainId;
        provider;
        bridgeAddress;
        zapBridgeAddress;
        bridgeInstance;
        zapBridge;
        l1BridgeZapEth = BridgeUtils.newL1BridgeZap(ChainId.ETH);
        bridgeConfig = new BridgeConfig();
        isL2ETHChain;
        requiredConfirmations;
        constructor(args) {
            let { network, provider } = args;
            this.network = network instanceof Networks.Network ? network : Networks.fromChainId(network);
            this.chainId = this.network.chainId;
            this.provider = provider ?? rpcProviderForChain(this.chainId);
            this.requiredConfirmations = getRequiredConfirmationsForBridge(this.network);
            this.isL2ETHChain = BridgeUtils.isL2ETHChain(this.chainId);
            const contractAddrs = SynapseContracts.contractsForChainId(this.chainId);
            this.bridgeAddress = contractAddrs.bridgeAddress;
            this.zapBridgeAddress = contractAddrs.bridgeZapAddress;
            this.bridgeInstance = SynapseEntities.SynapseBridgeContractInstance(BridgeUtils.entityParams(this.chainId));
            if (this.zapBridgeAddress && this.zapBridgeAddress !== "") {
                this.zapBridge = BridgeUtils.newBridgeZap(this.chainId);
            }
        }
        get l2BridgeZap() {
            return this.zapBridge;
        }
        bridgeVersion() {
            return this.bridgeInstance.bridgeVersion();
        }
        WETH_ADDRESS() {
            return this.bridgeInstance.WETH_ADDRESS();
        }
        kappaExists(kappa) {
            return this.bridgeInstance.kappaExists(kappa);
        }
        /**
         * Returns whether a swap/bridge from this Bridge's chain to another chain between two tokens
         * is supported.
         * @param {Token} args.tokenFrom {@link Token} user will send to the bridge
         * @param {Token} args.tokenTo {@link Token} user will receive from the bridge on the destination chain
         * @param {number} args.chainIdTo Chain ID of the destination chain
         * @return boolean value denoting whether the input params constitute a valid swap/bridge, along with a
         * string value denoting the reason for an unsupported swap, if applicable.
         */
        swapSupported(args) {
            const { swapSupported, reasonNotSupported } = bridgeSwapSupported({ ...args, chainIdFrom: this.chainId });
            return [swapSupported, reasonNotSupported?.reason || ""];
        }
        /**
         * Returns the estimated output of a given token on the destination chain were a user to send
         * some amount of another given token on the source chain.
         * @param {BridgeParams} args Parameters for the output estimation.
         * @return {Promise<BridgeOutputEstimate>} Object containing the estimated output of args.tokenTo, as well
         * as the estimated fee to be taken by the bridge. Note that the estimated output already accounts for the
         * bridge fee, so the bridge fee is entirely for user-facing purposes. Do not use it for calculations.
         */
        async estimateBridgeTokenOutput(args) {
            return this.checkSwapSupported(args)
                .then(() => this.calculateBridgeRate(args))
                .catch(rejectPromise);
        }
        /**
         * Returns a populated transaction for initiating a token bridge between this Bridge (the source chain) and the bridge contract on the destination chain.
         * Note that this function **does not** send a signed transaction.
         * @param {BridgeTransactionParams} args Parameters for the bridge transaction
         * @return {Promise<PopulatedTransaction>} Populated transaction instance which can be sent via ones choice
         * of web3/ethers/etc.
         */
        async buildBridgeTokenTransaction(args) {
            const { addressTo } = args, tokenArgs = this.makeBridgeTokenArgs(args), { tokenFrom, tokenTo } = tokenArgs;
            if ((!addressTo) || addressTo === "") {
                return rejectPromise(new Error("BridgeTransactionParams.addressTo cannot be empty string or undefined"));
            }
            args = { ...args, tokenFrom, tokenTo };
            let newTxn = this.chainId === ChainId.ETH
                ? this.buildETHMainnetBridgeTxn(args, tokenArgs)
                : this.buildL2BridgeTxn(args, tokenArgs);
            return newTxn
                .then(txn => GasUtils.populateGasParams(this.chainId, txn, "bridge"));
        }
        /**
         * Starts the Bridge process between this Bridge (the source chain) and the bridge contract on the destination chain.
         * Note that this function **does** send a signed transaction.
         * @param {BridgeTransactionParams} args Parameters for the bridge transaction.
         * @param {Signer} signer Some instance which implements the Ethersjs {@link Signer} interface.
         * @param {boolean} callStatic (Optional, default: false) if true, uses provider.callStatic instead of actually sending the signed transaction.
         * @return {Promise<ContractTransaction>}
         */
        async executeBridgeTokenTransaction(args, signer, callStatic = false) {
            try {
                await this.checkSwapSupported(args);
            }
            catch (e) { /* c8 ignore start */
                return rejectPromise(e);
            } /* c8 ignore stop */
            const { tokenFrom, amountFrom, addressTo } = args;
            const signerAddress = await signer.getAddress();
            if (!addressTo) { /* c8 ignore start */
                args.addressTo = signerAddress;
            } /* c8 ignore stop */
            const checkArgs = { signer, token: tokenFrom, amount: amountFrom };
            return this.checkCanBridge(checkArgs)
                .then(canBridgeRes => {
                const { canBridge, reasonUnable } = canBridgeRes;
                if (!canBridge) {
                    return rejectPromise(reasonUnable);
                }
                return this.buildBridgeTokenTransaction(args)
                    .then(txn => executePopulatedTransaction(txn, signer));
            })
                .catch(rejectPromise);
        }
        /**
         * Builds an ethers PopulatedTransaction instance for an ERC20 Approve call,
         * approving some amount of a given token to be spent by the Synapse Bridge on its chain.
         * The returned PopulatedTransaction must then be passed to the user via Web3 or some other
         * framework so they can ultimately send the transaction.
         * Should ALWAYS be called before performing any bridge transactions to ensure they don't fail.
         * @param {Object} args
         * @param {Token|string} args.token {@link Token} instance or valid on-chain address of the token the user will be sending
         * to the bridge on the source chain.
         * @param {BigNumberish} args.amount Optional, a specific amount of args.token to approve. By default, this function
         * builds an Approve call using an "infinite" approval amount.
         * @return {Promise<PopulatedTransaction>} Populated transaction instance which can be sent via ones choice
         * of web3/ethers/etc.
         */
        async buildApproveTransaction(args) {
            const [approveArgs, tokenAddress] = this.buildERC20ApproveArgs(args);
            return ERC20.buildApproveTransaction(approveArgs, { tokenAddress, chainId: this.chainId });
        }
        /**
         * Builds and executes an ERC20 Approve call,
         * approving some amount of a given token to be spent by the Synapse Bridge on its chain.
         * The returned PopulatedTransaction must then be passed to the user via Web3 or some other
         * framework so they can ultimately send the transaction.
         * Should ALWAYS be called before performing any bridge transactions to ensure they don't fail.
         * @param {Object} args
         * @param {Token|string} args.token {@link Token} instance or valid on-chain address of the token the user will be sending
         * to the bridge on the source chain.
         * @param {BigNumberish} args.amount Optional, a specific amount of args.token to approve. By default, this function
         * @param {Signer} signer Valid ethers Signer instance for building a fully and properly populated
         * transaction.
         */
        async executeApproveTransaction(args, signer) {
            const [approveArgs, tokenAddress] = this.buildERC20ApproveArgs(args), tokenParams = { tokenAddress, chainId: this.chainId };
            return ERC20.approve(approveArgs, tokenParams, signer);
        }
        async getAllowanceForAddress(args) {
            let { address, token } = args;
            let tokenAddress = token.address(this.chainId);
            return ERC20.allowanceOf(address, this.zapBridgeAddress, { tokenAddress, chainId: this.chainId });
        }
        async resolveApproveFunc(approveRes, hasBalanceRes, token) {
            const { needsApproval, currentAllowance } = approveRes;
            let allowanceEth;
            if (currentAllowance) {
                allowanceEth = formatUnits(currentAllowance, token.decimals(this.chainId)).toString();
            }
            const errStr = `Spend allowance of Bridge too low for token ${token.symbol}; current allowance for Bridge is ${allowanceEth}`;
            if (!needsApproval) {
                return hasBalanceRes;
            }
            return { canBridge: false, reasonUnable: errStr, amount: currentAllowance };
        }
        async checkNeedsApprove({ address, token, amount = MAX_APPROVAL_AMOUNT.sub(1) }) {
            const [{ spender }, tokenAddress] = this.buildERC20ApproveArgs({ token, amount });
            return ERC20.allowanceOf(address, spender, { tokenAddress, chainId: this.chainId })
                .then(currentAllowance => ({ needsApproval: currentAllowance.lt(amount), currentAllowance }));
        }
        async resolveBalanceFunc(prom, amount, token) {
            return Promise.resolve(prom)
                .then(balance => {
                const hasBalance = balance.gte(amount), balanceEth = formatUnits(balance, token.decimals(this.chainId)).toString();
                return (hasBalance
                    ? { canBridge: true }
                    : { canBridge: false, reasonUnable: `Balance of token ${token.symbol} is too low; current balance is ${balanceEth}`, amount: balance });
            })
                .catch(rejectPromise);
        }
        async checkGasTokenBalance(args) {
            const { address, token, amount } = args;
            const balanceProm = this.provider.getBalance(address);
            return this.resolveBalanceFunc(balanceProm, amount, token);
        }
        async checkCanBridge(args) {
            const { token, signer, address } = args;
            let signerAddress;
            if (address && address !== "") { /* c8 ignore start */
                signerAddress = address;
            }
            else {
                signerAddress = await signer.getAddress();
            } /* c8 ignore stop */
            const checkArgs = { ...args, address: signerAddress };
            const isGasTokenTransfer = (this.network.chainCurrency === token.symbol) && BridgeUtils.chainSupportsGasToken(this.chainId);
            let hasBalanceRes = isGasTokenTransfer
                ? this.checkGasTokenBalance(checkArgs)
                : this.checkERC20Balance(checkArgs);
            return isGasTokenTransfer
                ? hasBalanceRes
                : this.checkNeedsApprove(checkArgs)
                    .then(approveRes => this.resolveApproveFunc(approveRes, hasBalanceRes, token))
                    .catch(rejectPromise);
        }
        async checkERC20Balance(args) {
            const { address, amount, token } = args, tokenAddress = token.address(this.chainId);
            return this.resolveBalanceFunc(ERC20.balanceOf(address, { tokenAddress, chainId: this.chainId }), amount, token);
        }
        buildERC20ApproveArgs(args) {
            const { token, amount } = args;
            let spender = this.zapBridgeAddress;
            if (instanceOfToken(token) && token.isEqual(Tokens.MULTIJEWEL)) {
                spender = SynapseEntities.AvaxJewelMigrationAddress;
            }
            /* c8 ignore start */
            let tokenAddr = instanceOfToken(token)
                ? token.address(this.chainId)
                : token;
            /* c8 ignore stop */
            return [{
                    spender,
                    amount
                }, tokenAddr];
        }
        async checkSwapSupported(args) {
            return new Promise((resolve, reject) => {
                let [swapSupported, errReason] = this.swapSupported(args);
                if (!swapSupported) {
                    reject(errReason);
                    return;
                }
                resolve(true);
            });
        }
        async calculateBridgeRate(args) {
            let { chainIdTo, amountFrom } = args;
            const l2BridgeZapTo = BridgeUtils.newL2BridgeZap(chainIdTo);
            const { tokenFrom, tokenTo, tokenIndexFrom, tokenIndexTo, fromChainTokens } = this.makeBridgeTokenArgs(args);
            let { intermediateToken } = TokenSwap.intermediateTokens(chainIdTo, tokenFrom);
            const { bridgeFee: bridgeFeeRequest, amountFrom: amountFromFixedDecimals } = this.bridgeConfig.calculateSwapFee({
                chainIdFrom: this.chainId,
                tokenFrom,
                chainIdTo,
                amountFrom
            });
            const checkEthBridge = (c1, c2, t) => c1 === ChainId.ETH && BridgeUtils.isL2ETHChain(c2) && t.swapType === SwapType.ETH;
            const ethToEth = checkEthBridge(this.chainId, chainIdTo, tokenTo), ethFromEth = checkEthBridge(chainIdTo, this.chainId, tokenFrom);
            let amountToReceive_from_prom;
            if (amountFrom.isZero()) {
                amountToReceive_from_prom = Promise.resolve(Zero);
            }
            else if (ethToEth || Tokens.isMintBurnToken(tokenFrom) || tokenFrom.isWrapperToken) {
                amountToReceive_from_prom = Promise.resolve(amountFromFixedDecimals);
            }
            else if (this.chainId === ChainId.ETH) {
                let liquidityAmounts = fromChainTokens.map((t) => tokenFrom.isEqual(t) ? amountFrom : Zero);
                amountToReceive_from_prom = this.l1BridgeZapEth.calculateTokenAmount(liquidityAmounts, true);
            }
            else {
                amountToReceive_from_prom = this.l2BridgeZap.calculateSwap(intermediateToken.address(this.chainId), tokenIndexFrom, 0, amountFrom);
            }
            let amountToReceive_from = await amountToReceive_from_prom;
            let bridgeFee;
            try { /* c8 ignore start */
                bridgeFee = await bridgeFeeRequest;
                if (bridgeFee === null) {
                    console.error("calculateSwapFee returned null");
                    return rejectPromise("calculateSwapFee returned null");
                }
            }
            catch (e) {
                console.error(`Error in bridge fee request: ${e}`);
                return rejectPromise(e);
            } /* c8 ignore stop */
            amountToReceive_from = BridgeUtils.subBigNumSafe(amountToReceive_from, bridgeFee);
            let amountToReceive_to_prom;
            if (amountToReceive_from.isZero()) {
                amountToReceive_to_prom = Promise.resolve(Zero);
            }
            else if (ethFromEth || Tokens.isMintBurnToken(tokenTo) || tokenTo.isWrapperToken) {
                amountToReceive_to_prom = Promise.resolve(amountToReceive_from);
            }
            else if (chainIdTo === ChainId.ETH) {
                amountToReceive_to_prom =
                    this.l1BridgeZapEth.calculateRemoveLiquidityOneToken(amountToReceive_from, tokenIndexTo);
            }
            else {
                amountToReceive_to_prom = l2BridgeZapTo.calculateSwap(intermediateToken.address(chainIdTo), 0, tokenIndexTo, amountToReceive_from);
            }
            let amountToReceive;
            try { /* c8 ignore start */
                amountToReceive = await Promise.resolve(amountToReceive_to_prom);
            }
            catch (err) {
                return rejectPromise(err);
            } /* c8 ignore stop */
            return { amountToReceive, bridgeFee };
        }
        checkEasyArgs(args, zapBridge, easyDeposits, easyRedeems, easyDepositETH) {
            let castArgs = args, isEasy = false, txn;
            const params = BridgeUtils.makeEasyParams(castArgs, this.chainId, args.tokenTo);
            switch (true) {
                case easyRedeems.includes(args.tokenTo.id):
                    isEasy = true;
                    txn = zapBridge.populateTransaction.redeem(...params);
                    break;
                case easyDeposits.includes(args.tokenTo.id):
                    isEasy = true;
                    txn = zapBridge.populateTransaction.deposit(...params);
                    break;
                case easyDepositETH.includes(args.tokenTo.id):
                    isEasy = true;
                    txn = zapBridge
                        .populateTransaction
                        .depositETH(...BridgeUtils.depositETHParams(castArgs), BridgeUtils.overrides(args.amountFrom));
                    break;
            }
            return { castArgs, isEasy, txn };
        }
        buildETHMainnetBridgeTxn(args, tokenArgs) {
            const { addressTo, chainIdTo, amountFrom, amountTo } = args;
            let easyRedeems = [Tokens.SYN.id, Tokens.UST.id], easyDeposits = [
                Tokens.HIGH.id, Tokens.DOG.id, Tokens.FRAX.id,
                Tokens.GOHM.id, Tokens.NEWO.id, Tokens.SDT.id,
            ], easyDepositETH = [Tokens.NETH.id];
            let { castArgs, isEasy, txn } = this.checkEasyArgs(args, this.l1BridgeZapEth, easyDeposits, easyRedeems, easyDepositETH);
            if (isEasy && txn) {
                return txn;
            }
            const liquidityAmounts = tokenArgs.fromChainTokens.map(t => args.tokenFrom.isEqual(t)
                ? amountFrom
                : Zero);
            const { transactionDeadline, bridgeTransactionDeadline, minToSwapDestFromOrigin, minToSwapDest, minToSwapOriginMediumSlippage, minToSwapDestFromOriginMediumSlippage, } = BridgeUtils.getSlippages(amountFrom, amountTo);
            if (args.tokenTo.isEqual(Tokens.NUSD) || args.tokenTo.isEqual(Tokens.DFK_USDC)) {
                if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC)) {
                    const bridgeDepositArgs = BridgeUtils.makeEasyParams(args, this.chainId, Tokens.NUSD);
                    return this.l1BridgeZapEth
                        .populateTransaction
                        .deposit(...bridgeDepositArgs);
                }
                else {
                    return this.l1BridgeZapEth.populateTransaction.zapAndDeposit(addressTo, chainIdTo, Tokens.NUSD.address(this.chainId), liquidityAmounts, minToSwapDest, transactionDeadline);
                }
            }
            if (BridgeUtils.isETHLikeToken(args.tokenTo) || args.tokenTo.isEqual(Tokens.WETH)) {
                return this.l1BridgeZapEth.populateTransaction.depositETHAndSwap(...BridgeUtils.depositETHParams(castArgs), 0, // nusd tokenindex,
                tokenArgs.tokenIndexTo, minToSwapDestFromOrigin, // minDy
                bridgeTransactionDeadline, BridgeUtils.overrides(amountFrom));
            }
            else if (args.tokenFrom.isEqual(Tokens.NUSD)) {
                return this.l1BridgeZapEth.populateTransaction.depositAndSwap(addressTo, chainIdTo, Tokens.NUSD.address(this.chainId), amountFrom, 0, tokenArgs.tokenIndexTo, minToSwapDestFromOriginMediumSlippage, bridgeTransactionDeadline);
            }
            return this.l1BridgeZapEth.populateTransaction.zapAndDepositAndSwap(addressTo, chainIdTo, Tokens.NUSD.address(this.chainId), liquidityAmounts, minToSwapOriginMediumSlippage, // minToSwapOrigin,
            transactionDeadline, 0, tokenArgs.tokenIndexTo, minToSwapDestFromOriginMediumSlippage, //, minToSwapDestFromOrigin, // minDy
            bridgeTransactionDeadline);
        }
        buildL2BridgeTxn(args, tokenArgs) {
            const { chainIdTo, amountFrom, amountTo } = args, zapBridge = SynapseEntities.L2BridgeZapContractInstance({
                chainId: this.chainId,
                signerOrProvider: this.provider
            });
            tokenArgs.tokenFrom = tokenArgs.tokenFrom.isEqual(Tokens.AVWETH)
                ? Tokens.WETH_E
                : tokenArgs.tokenFrom;
            if (tokenArgs.tokenFrom.isEqual(Tokens.MULTIJEWEL)) {
                const jewelMigrator = SynapseEntities.AvaxJewelMigrationContractInstance();
                return jewelMigrator
                    .populateTransaction
                    .migrateAndBridge(args.amountFrom, args.addressTo, args.chainIdTo);
            }
            let easyDeposits = [], easyDepositETH = [], easyRedeems = [
                Tokens.SYN.id, Tokens.HIGH.id, Tokens.DOG.id,
                Tokens.FRAX.id, Tokens.UST.id, Tokens.GOHM.id,
                Tokens.NEWO.id, Tokens.SDT.id, Tokens.LUNA.id,
            ];
            BridgeUtils.DepositIfChainTokens.forEach((depositIfChainArgs) => {
                if (this.chainId === ChainId.DFK && args.tokenTo.isEqual(Tokens.SYN_AVAX)) {
                    return;
                }
                let { chainId, tokens, depositEth, redeemChainIds } = depositIfChainArgs;
                let hasAltChains = redeemChainIds.length > 0, tokenHashes = tokens.map((t) => t.id);
                if (this.chainId === chainId) {
                    if (depositEth) {
                        easyDepositETH.push(...tokenHashes);
                    }
                    else {
                        easyDeposits.push(...tokenHashes);
                    }
                }
                else {
                    if (hasAltChains && redeemChainIds.includes(this.chainId)) {
                        easyRedeems.push(...tokenHashes);
                    }
                }
            });
            const dfkBridgeZap = BridgeUtils.newL1BridgeZap(ChainId.DFK), checkEasyZap = this.chainId === ChainId.DFK ? dfkBridgeZap : this.zapBridge;
            let { castArgs, isEasy, txn } = this.checkEasyArgs(args, checkEasyZap, easyDeposits, easyRedeems, easyDepositETH);
            if (isEasy && txn) {
                return txn;
            }
            const { transactionDeadline, bridgeTransactionDeadline, minToSwapOriginHighSlippage, minToSwapDestFromOriginMediumSlippage, minToSwapDestFromOriginHighSlippage, minToSwapDest, } = BridgeUtils.getSlippages(amountFrom, amountTo);
            const easyRedeemAndSwap = (baseToken) => zapBridge
                .populateTransaction
                .redeemAndSwap(...BridgeUtils.makeEasyParams(castArgs, this.chainId, baseToken), 0, tokenArgs.tokenIndexTo, minToSwapDest, transactionDeadline);
            const easySwapAndRedeem = (baseToken, swapETH = false) => {
                let populateFn = swapETH
                    ? zapBridge.populateTransaction.swapETHAndRedeem
                    : zapBridge.populateTransaction.swapAndRedeem;
                return populateFn(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, baseToken), tokenArgs.tokenIndexFrom, 0, amountFrom, minToSwapOriginHighSlippage, // minToSwapOrigin, // minToSwapOriginHighSlippage,
                transactionDeadline, swapETH ? BridgeUtils.overrides(amountFrom) : {});
            };
            const easySwapAndRedeemAndSwap = (baseToken, swapETH = false) => {
                let populateFn = swapETH
                    ? zapBridge.populateTransaction.swapETHAndRedeemAndSwap
                    : zapBridge.populateTransaction.swapAndRedeemAndSwap;
                return populateFn(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, baseToken), tokenArgs.tokenIndexFrom, 0, amountFrom, minToSwapOriginHighSlippage, transactionDeadline, 0, tokenArgs.tokenIndexTo, minToSwapDestFromOriginHighSlippage, // swapMinAmount
                bridgeTransactionDeadline, // toSwapDeadline, // swapDeadline
                swapETH ? BridgeUtils.overrides(amountFrom) : {});
            };
            switch (tokenSwitch(args.tokenTo)) {
                case Tokens.NUSD:
                case Tokens.DFK_USDC:
                    if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC)) {
                        return zapBridge
                            .populateTransaction
                            .redeem(...BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.NUSD));
                    }
                    return zapBridge
                        .populateTransaction
                        .swapAndRedeem(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.NUSD), tokenArgs.tokenIndexFrom, 0, amountFrom, minToSwapOriginHighSlippage, transactionDeadline);
                case Tokens.GMX:
                    let params = BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.GMX);
                    let [addrTo, chainTo, , amount] = params;
                    return this.chainId === ChainId.ARBITRUM
                        ? zapBridge.populateTransaction.deposit(...params)
                        : this.bridgeInstance
                            .populateTransaction
                            .redeem(addrTo, chainTo, Tokens.GMX.wrapperAddress(this.chainId), amount);
                case Tokens.JEWEL:
                    if (this.chainId === ChainId.HARMONY) {
                        return zapBridge
                            .populateTransaction
                            .swapAndRedeem(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.SYN_JEWEL), 0, 1, amountFrom, minToSwapOriginHighSlippage, // minToSwapOrigin, // minToSwapOriginHighSlippage,
                        transactionDeadline);
                    }
                    else if (this.chainId === ChainId.DFK) {
                        if (args.chainIdTo === ChainId.HARMONY) {
                            return dfkBridgeZap.populateTransaction.depositETHAndSwap(args.addressTo, args.chainIdTo, args.amountFrom, 1, 0, minToSwapDestFromOriginMediumSlippage, bridgeTransactionDeadline, BridgeUtils.overrides(args.amountFrom));
                        }
                        return dfkBridgeZap.populateTransaction.depositETH(args.addressTo, args.chainIdTo, args.amountFrom, BridgeUtils.overrides(args.amountFrom));
                    }
                    if (chainIdTo === ChainId.DFK) {
                        return zapBridge.populateTransaction.redeem(args.addressTo, ChainId.DFK, Tokens.JEWEL.address(this.chainId), args.amountFrom);
                    }
                    return zapBridge.populateTransaction.redeemAndSwap(args.addressTo, args.chainIdTo, Tokens.JEWEL.address(this.chainId), args.amountFrom, 1, 0, minToSwapDest, transactionDeadline);
                case Tokens.SYN_JEWEL:
                    if (this.chainId === ChainId.DFK) {
                        return dfkBridgeZap
                            .populateTransaction
                            .depositETH(args.addressTo, args.chainIdTo, args.amountFrom, BridgeUtils.overrides(args.amountFrom));
                    }
                    return zapBridge
                        .populateTransaction
                        .swapAndRedeem(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.JEWEL), 0, 1, amountFrom, minToSwapOriginHighSlippage, // minToSwapOrigin, // minToSwapOriginHighSlippage,
                    transactionDeadline);
                case Tokens.SYN_AVAX:
                    if (this.chainId === ChainId.DFK) {
                        return dfkBridgeZap
                            .populateTransaction
                            .redeem(...BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.WAVAX));
                    }
                    return zapBridge
                        .populateTransaction
                        .depositETH(castArgs.addressTo, castArgs.chainIdTo, castArgs.amountFrom, BridgeUtils.overrides(castArgs.amountFrom));
                default:
                    if (chainIdTo === ChainId.ETH) {
                        if (this.isL2ETHChain && args.tokenFrom.swapType === SwapType.ETH) {
                            if (args.tokenFrom.isEqual(Tokens.NETH)) {
                                return zapBridge
                                    .populateTransaction
                                    .redeem(...BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.NETH));
                            }
                            else {
                                let useSwapETH = !BridgeUtils.isETHLikeToken(args.tokenFrom);
                                return easySwapAndRedeem(Tokens.NETH, useSwapETH);
                            }
                        }
                        else if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC)) {
                            return zapBridge
                                .populateTransaction
                                .redeemAndRemove(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.NUSD), amountFrom, tokenArgs.tokenIndexTo, minToSwapDest, transactionDeadline);
                        }
                        return zapBridge
                            .populateTransaction
                            .swapAndRedeemAndRemove(...BridgeUtils.makeEasySubParams(castArgs, this.chainId, Tokens.NUSD), tokenArgs.tokenIndexFrom, 0, amountFrom, minToSwapOriginHighSlippage, transactionDeadline, tokenArgs.tokenIndexTo, //swapTokenIndex
                        minToSwapDestFromOriginHighSlippage, // swapMinAmount
                        bridgeTransactionDeadline);
                    }
                    if (this.chainId === ChainId.HARMONY && args.tokenFrom.isEqual(Tokens.SYN_AVAX)) {
                        const redeemArgs = BridgeUtils.makeEasyParams(castArgs, this.chainId, Tokens.SYN_AVAX);
                        return zapBridge
                            .populateTransaction
                            .redeem(...redeemArgs);
                    }
                    if (args.tokenFrom.isEqual(Tokens.NUSD) || args.tokenFrom.isEqual(Tokens.DFK_USDC) || args.tokenFrom.isEqual(Tokens.NETH)) {
                        return easyRedeemAndSwap(args.tokenFrom);
                    }
                    if (args.tokenFrom.swapType === SwapType.ETH) {
                        let useSwapETH = !BridgeUtils.isETHLikeToken(args.tokenFrom);
                        return easySwapAndRedeemAndSwap(Tokens.NETH, useSwapETH);
                    }
                    return easySwapAndRedeemAndSwap(Tokens.NUSD);
            }
        }
        makeBridgeTokenArgs(args) {
            let { tokenFrom, tokenTo, chainIdTo } = args;
            let bridgeTokens;
            switch (tokenFrom.swapType) {
                case SwapType.ETH:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.ETH, Tokens.WETH);
                    break;
                case SwapType.AVAX:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.AVAX, Tokens.WAVAX);
                    break;
                case SwapType.MOVR:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.MOVR, Tokens.WMOVR);
                    break;
                case SwapType.JEWEL:
                    bridgeTokens = BridgeUtils.checkReplaceTokens(Tokens.GAS_JEWEL, Tokens.JEWEL);
                    break;
                default:
                    bridgeTokens = (t1, t2) => [t1, t2];
            }
            [tokenFrom, tokenTo] = bridgeTokens(tokenFrom, tokenTo);
            const [fromChainTokens, tokenIndexFrom] = BridgeUtils.makeTokenArgs(this.chainId, tokenFrom), [toChainTokens, tokenIndexTo] = BridgeUtils.makeTokenArgs(chainIdTo, tokenTo);
            return {
                fromChainTokens,
                toChainTokens,
                tokenFrom,
                tokenTo,
                tokenIndexFrom,
                tokenIndexTo
            };
        }
    }
    Bridge.SynapseBridge = SynapseBridge;
    const REQUIRED_CONFS = {
        [ChainId.ETH]: 7,
        [ChainId.OPTIMISM]: 1,
        [ChainId.CRONOS]: 6,
        [ChainId.BSC]: 14,
        [ChainId.POLYGON]: 128,
        [ChainId.FANTOM]: 5,
        [ChainId.BOBA]: 1,
        [ChainId.METIS]: 6,
        [ChainId.MOONBEAM]: 21,
        [ChainId.MOONRIVER]: 21,
        [ChainId.ARBITRUM]: 40,
        [ChainId.AVALANCHE]: 5,
        [ChainId.DFK]: 1,
        [ChainId.HARMONY]: 1,
        [ChainId.AURORA]: 5,
    };
    function getRequiredConfirmationsForBridge(network) {
        let chainId = network instanceof Networks.Network ? network.chainId : network;
        if (chainId in REQUIRED_CONFS) {
            return REQUIRED_CONFS[chainId];
        }
        return null;
    }
    Bridge.getRequiredConfirmationsForBridge = getRequiredConfirmationsForBridge;
    function bridgeSwapSupported(args) {
        return TokenSwap.bridgeSwapSupported(args);
    }
    Bridge.bridgeSwapSupported = bridgeSwapSupported;
    function checkBridgeTransactionComplete(args) {
        const { chainIdTo, transactionHashChainFrom } = args, kappa = makeKappa(transactionHashChainFrom), bridgeInstance = new SynapseBridge({ network: chainIdTo });
        return bridgeInstance.kappaExists(kappa)
            .then(res => res)
            .catch(rejectPromise);
    }
    Bridge.checkBridgeTransactionComplete = checkBridgeTransactionComplete;
})(Bridge || (Bridge = {}));
