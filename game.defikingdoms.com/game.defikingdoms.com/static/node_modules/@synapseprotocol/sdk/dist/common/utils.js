import { ChainId } from "./chainid.js";
import { SynapseContracts } from "./synapse_contracts.js";
import { StaticCallResult } from "./types.js";
import { BigNumber } from "@ethersproject/bignumber";
export function rejectPromise(e) { return Promise.reject(e instanceof Error ? e : new Error(e)); }
export function executePopulatedTransaction(populatedTxn, signer) {
    return Promise.resolve(populatedTxn)
        .then(txn => signer.sendTransaction(txn))
        .catch(rejectPromise);
}
export function staticCallPopulatedTransaction(populatedTxn, signer) {
    return Promise.resolve(populatedTxn)
        .then(txn => {
        return signer.call(txn)
            .then(() => StaticCallResult.Success)
            .catch((err) => StaticCallResult.Failure);
    });
}
export function pow10(exp) { return BigNumber.from(10).pow(exp); }
/**
 * "Fixes" a value into units of Wei; should be used when tokens
 * have a decimals value which isn't 18
 * (such as USDC/USDT on chains which aren't BSC) and you need to do
 * calculations using proper units of Wei instead of, for example in the case of
 * USDC/USDT, Szabo (10^-6)
 * @param amt
 * @param decimals
 */
export function fixWeiValue(amt, decimals) {
    const multiplier = pow10(18).div(pow10(decimals));
    return amt.mul(multiplier);
}
export function contractAddressFor(chainId, key) {
    let address;
    const contractsForChain = contractsForChainId(chainId);
    switch (key) {
        case "bridgeAddress":
            address = contractsForChain.bridgeAddress;
            break;
        case "bridgeZapAddress":
            address = contractsForChain.bridgeZapAddress;
            break;
    }
    return address;
}
const CHAINID_CONTRACTS_MAP = {
    [ChainId.ETH]: SynapseContracts.Ethereum,
    [ChainId.OPTIMISM]: SynapseContracts.Optimism,
    [ChainId.CRONOS]: SynapseContracts.Cronos,
    [ChainId.BSC]: SynapseContracts.BSC,
    [ChainId.POLYGON]: SynapseContracts.Polygon,
    [ChainId.FANTOM]: SynapseContracts.Fantom,
    [ChainId.BOBA]: SynapseContracts.Boba,
    [ChainId.METIS]: SynapseContracts.Metis,
    [ChainId.MOONBEAM]: SynapseContracts.Moonbeam,
    [ChainId.MOONRIVER]: SynapseContracts.Moonriver,
    [ChainId.ARBITRUM]: SynapseContracts.Arbitrum,
    [ChainId.AVALANCHE]: SynapseContracts.Avalanche,
    [ChainId.DFK]: SynapseContracts.DFK,
    [ChainId.AURORA]: SynapseContracts.Aurora,
    [ChainId.HARMONY]: SynapseContracts.Harmony,
};
export const contractsForChainId = (chainId) => CHAINID_CONTRACTS_MAP[chainId] ?? null;
