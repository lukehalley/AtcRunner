import _ from "lodash";
import { ChainId, supportedChainIds } from "./common/chainid.js";
import { Networks } from "./common/networks.js";
import { Tokens } from "./tokens.js";
import { SwapPools } from "./swappools.js";
import { rejectPromise } from "./common/utils.js";
import { BridgeConfigV3ContractInstance } from "./entities.js";
import { SwapFactory } from "./contracts.js";
import { SwapType, mintBurnSwapTypes } from "./internal/swaptype.js";
import { rpcProviderForChain } from "./internal/rpcproviders.js";
export var UnsupportedSwapErrors;
(function (UnsupportedSwapErrors) {
    let UnsupportedSwapErrorKind;
    (function (UnsupportedSwapErrorKind) {
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedToken"] = 0] = "UnsupportedToken";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedTokenNetFrom"] = 1] = "UnsupportedTokenNetFrom";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedTokenNetTo"] = 2] = "UnsupportedTokenNetTo";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["NonmatchingSwapTypes"] = 3] = "NonmatchingSwapTypes";
        UnsupportedSwapErrorKind[UnsupportedSwapErrorKind["UnsupportedMultiJEWELMigration"] = 4] = "UnsupportedMultiJEWELMigration";
    })(UnsupportedSwapErrorKind = UnsupportedSwapErrors.UnsupportedSwapErrorKind || (UnsupportedSwapErrors.UnsupportedSwapErrorKind = {}));
    class UnsupportedSwapError extends Error {
        reason;
        errorKind;
        constructor({ reason, errorKind }) {
            super(reason);
            this.name = this.constructor.name;
            Error.captureStackTrace(this, this.constructor);
            this.reason = reason;
            this.errorKind = errorKind;
        }
    }
    UnsupportedSwapErrors.UnsupportedSwapError = UnsupportedSwapError;
    UnsupportedSwapErrors.tokenNotSupported = (t, netName) => new UnsupportedSwapError({
        reason: `Token ${t.symbol} not supported on network ${netName}`,
        errorKind: UnsupportedSwapErrorKind.UnsupportedToken,
    });
    UnsupportedSwapErrors.tokenNotSupportedNetFrom = (t, netName) => new UnsupportedSwapError({
        reason: `Token ${t.symbol} not supported on 'from' network ${netName}`,
        errorKind: UnsupportedSwapErrorKind.UnsupportedTokenNetFrom,
    });
    UnsupportedSwapErrors.tokenNotSupportedNetTo = (t, netName) => new UnsupportedSwapError({
        reason: `Token ${t.symbol} not supported on 'to' network ${netName}`,
        errorKind: UnsupportedSwapErrorKind.UnsupportedTokenNetTo,
    });
    UnsupportedSwapErrors.nonMatchingSwapTypes = () => new UnsupportedSwapError({
        reason: "Token swap types don't match",
        errorKind: UnsupportedSwapErrorKind.NonmatchingSwapTypes,
    });
    UnsupportedSwapErrors.unsupportedMultiJEWELMigration = () => new UnsupportedSwapError({
        reason: "Migrating multiJEWEL from Avalanche to Harmony is not supported",
        errorKind: UnsupportedSwapErrorKind.UnsupportedMultiJEWELMigration,
    });
})(UnsupportedSwapErrors || (UnsupportedSwapErrors = {}));
export var TokenSwap;
(function (TokenSwap) {
    const BRIDGE_CONFIG_INSTANCE = BridgeConfigV3ContractInstance();
    function swapSupported(args) {
        const { tokenFrom, tokenTo, chainId } = args;
        return checkCanSwap(tokenFrom, tokenTo, chainId);
    }
    TokenSwap.swapSupported = swapSupported;
    function bridgeSwapSupported(args) {
        const { tokenFrom, tokenTo, chainIdFrom, chainIdTo } = args;
        return checkCanSwap(tokenFrom, tokenTo, chainIdFrom, chainIdTo);
    }
    TokenSwap.bridgeSwapSupported = bridgeSwapSupported;
    async function calculateSwapRate(args) {
        const { swapSupported: canSwap, reasonNotSupported } = swapSupported(args);
        if (!canSwap) {
            return rejectPromise(reasonNotSupported);
        }
        return resolveSwapData(args)
            .then(({ swapInstance, tokenIndexFrom, tokenIndexTo }) => swapInstance
            .calculateSwap(tokenIndexFrom, tokenIndexTo, args.amountIn)
            .then((res) => ({ amountOut: res })))
            .catch(rejectPromise);
    }
    TokenSwap.calculateSwapRate = calculateSwapRate;
    async function buildSwapTokensTransaction(args) {
        const { swapSupported: canSwap, reasonNotSupported } = swapSupported(args);
        if (!canSwap) {
            return rejectPromise(reasonNotSupported);
        }
        return resolveSwapData(args)
            .then(populateSwapTransaction(args))
            .catch(rejectPromise);
    }
    TokenSwap.buildSwapTokensTransaction = buildSwapTokensTransaction;
    async function resolveSwapData(args) {
        const { swapData } = args;
        return Promise.resolve(swapData ? swapData : await swapSetup(args.tokenFrom, args.tokenTo, args.chainId));
    }
    function populateSwapTransaction(args) {
        return (swapSetup) => {
            let { deadline } = args;
            const { swapInstance, tokenIndexFrom, tokenIndexTo } = swapSetup;
            deadline = deadline ?? Math.round((new Date().getTime() / 1000) + 60 * 10);
            const overrides = args.tokenFrom.isEqual(Tokens.ETH) ? { value: args.amountIn } : {};
            return swapInstance.populateTransaction.swap(tokenIndexFrom, tokenIndexTo, args.amountIn, args.minAmountOut, deadline, overrides);
        };
    }
    function intermediateTokens(chainId, token) {
        if (mintBurnSwapTypes.includes(token.swapType)) {
            if (token.swapType === SwapType.JEWEL) {
                let bridgeConfigIntermediate = chainId === ChainId.HARMONY
                    ? Tokens.SYN_JEWEL
                    : Tokens.JEWEL;
                return { intermediateToken: Tokens.JEWEL, bridgeConfigIntermediateToken: bridgeConfigIntermediate };
            }
            return { intermediateToken: token, bridgeConfigIntermediateToken: token };
        }
        let intermediateToken, bridgeConfigIntermediateToken;
        switch (token.swapType) {
            case SwapType.SYN:
                intermediateToken = Tokens.SYN;
                break;
            case SwapType.FRAX:
                bridgeConfigIntermediateToken = chainId === ChainId.ETH ? Tokens.FRAX : Tokens.SYN_FRAX;
                break;
            case SwapType.ETH:
                intermediateToken = Tokens.NETH;
                bridgeConfigIntermediateToken = chainId === ChainId.ETH ? Tokens.WETH : Tokens.NETH;
                break;
            case SwapType.AVAX:
                intermediateToken = Tokens.WAVAX;
                bridgeConfigIntermediateToken = chainId === ChainId.HARMONY ? Tokens.SYN_AVAX : Tokens.WAVAX;
                break;
            case SwapType.MOVR:
                intermediateToken = Tokens.WMOVR;
                break;
            default:
                intermediateToken = Tokens.NUSD;
                break;
        }
        bridgeConfigIntermediateToken = bridgeConfigIntermediateToken ?? intermediateToken;
        return { intermediateToken, bridgeConfigIntermediateToken };
    }
    TokenSwap.intermediateTokens = intermediateTokens;
    function detailedTokenSwapMap() {
        let res = {};
        const allChainIds = supportedChainIds();
        for (const c1 of allChainIds) {
            let n1 = Networks.fromChainId(c1);
            let networkTokens = n1.tokens;
            const chainGasToken = Tokens.gasTokenForChain(c1);
            res[c1] = networkTokens.map((t) => {
                let swapType = t.swapType;
                if (!_.isNull(chainGasToken)) {
                    const gasWrapper = Tokens.gasTokenWrapper(chainGasToken);
                    if (gasWrapper.isEqual(t)) {
                        return;
                    }
                }
                let tokSwapMap = {
                    token: t,
                };
                for (const c2 of allChainIds) {
                    if (c1 === c2)
                        continue;
                    if (c1 === ChainId.AVALANCHE && t.isEqual(Tokens.MULTIJEWEL) && c2 !== ChainId.DFK) {
                        continue;
                    }
                    const chain2GasToken = Tokens.gasTokenForChain(c2);
                    let outToks = SwapPools.tokensForChainBySwapGroup(c2, swapType);
                    if (outToks.length === 0)
                        continue;
                    outToks = outToks.filter((t2) => {
                        if (!_.isNull(chain2GasToken)) {
                            return !Tokens.gasTokenWrapper(chain2GasToken).isEqual(t2);
                        }
                        return true;
                    });
                    tokSwapMap[c2] = outToks;
                }
                return tokSwapMap;
            }).filter(t => !_.isUndefined(t));
        }
        return res;
    }
    TokenSwap.detailedTokenSwapMap = detailedTokenSwapMap;
    async function swapContract(token, chainId) {
        const lpToken = _intermediateToken(token, chainId);
        return BRIDGE_CONFIG_INSTANCE.getPoolConfig(lpToken.address(chainId), chainId)
            .then(({ poolAddress }) => SwapFactory.connect(poolAddress, rpcProviderForChain(chainId)))
            .catch(rejectPromise);
    }
    async function swapSetup(tokenFrom, tokenTo, chainId) {
        const swapInstance = await swapContract(tokenFrom, chainId);
        return Promise.all([
            swapInstance.getTokenIndex(tokenFrom.address(chainId)),
            swapInstance.getTokenIndex(tokenTo.address(chainId)),
        ]).then(([tokenIndexFrom, tokenIndexTo]) => ({
            swapInstance,
            tokenIndexFrom,
            tokenIndexTo,
        })).catch(rejectPromise);
    }
    TokenSwap.swapSetup = swapSetup;
    function _intermediateToken(token, chainId) {
        const { intermediateToken, bridgeConfigIntermediateToken } = intermediateTokens(chainId, token);
        return intermediateToken ?? bridgeConfigIntermediateToken;
    }
    function checkCanSwap(tokenFrom, tokenTo, chainFrom, chainTo) {
        const tokensCanSwap = checkTokensCanSwap(tokenFrom, tokenTo), tokensSupported = checkTokensSupported(tokenFrom, tokenTo, chainFrom, chainTo);
        if (!tokensSupported.swapSupported) {
            return tokensSupported;
        }
        else if (!tokensCanSwap.swapSupported) {
            return tokensCanSwap;
        }
        return { swapSupported: true };
    }
    function checkTokensCanSwap(tokenFrom, tokenTo) {
        let swapSupported = true, reasonNotSupported;
        if (tokenFrom.swapType !== tokenTo.swapType) {
            swapSupported = false;
            reasonNotSupported = UnsupportedSwapErrors.nonMatchingSwapTypes();
        }
        return { swapSupported, reasonNotSupported };
    }
    function checkTokensSupported(tokenFrom, tokenTo, chainIdFrom, chainIdTo) {
        const hasDestChain = !_.isUndefined(chainIdTo);
        const unsupportedFromErr = hasDestChain ? UnsupportedSwapErrors.tokenNotSupportedNetFrom : UnsupportedSwapErrors.tokenNotSupported, unsupportedToErr = hasDestChain ? UnsupportedSwapErrors.tokenNotSupportedNetTo : UnsupportedSwapErrors.tokenNotSupported;
        const netFrom = Networks.fromChainId(chainIdFrom), netTo = hasDestChain ? Networks.fromChainId(chainIdTo) : netFrom;
        if (hasDestChain) {
            if (tokenFrom.isEqual(Tokens.MULTIJEWEL) && chainIdTo !== ChainId.DFK) {
                return { swapSupported: false, reasonNotSupported: UnsupportedSwapErrors.unsupportedMultiJEWELMigration() };
            }
        }
        let swapSupported = true, reasonNotSupported;
        if (!netFrom.supportsToken(tokenFrom)) {
            swapSupported = false;
            reasonNotSupported = unsupportedFromErr(tokenFrom, netFrom.name);
        }
        else if (!netTo.supportsToken(tokenTo)) {
            swapSupported = false;
            reasonNotSupported = unsupportedToErr(tokenTo, netTo.name);
        }
        return { swapSupported, reasonNotSupported };
    }
})(TokenSwap || (TokenSwap = {}));
